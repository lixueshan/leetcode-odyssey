

# 137-只出现一次的数字2

[137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

<br />

## 解法一：哈希表

### 算法描述

遍历nums，将数字与出现次数以\<k, v>形式存入map中。然后遍历map，找到v = 1的k，即为所求。

<br />

### 时空复杂度

时间复杂度：O(n)

空间复杂度：O(n)

<br />

### 代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for(int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == 1) {
                ans = entry.getKey();
                break;
            }
        }
        return ans;
    }
}
```

<br />

## 解法二：取余

### 算法描述

将只出现一次的数称为ans。由于除ans外，每个数都出现了三次，考虑所有数的二进制形式，除ans外，所有数的同一位的"1"的数量总和都是3的倍数（若所有数某位无1，为0倍）。统计每一位的1的总和余3的结果，就是ans在该位上的值。由于nums是int数组，故最多32位，执行32次统计求余，并累计结果即可。



此方法的优点其通用性，即适用于除了某个数只出现1次，其余数都出现k次的一般情形，只需调整REPEAT = k即可。

<br />

### 时空复杂度

时间复杂度：O(n), 更准确地说是O(32*n)，n位nums大小。

空间复杂度：O(1)。

<br />

### 代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0, REPEAT = 3;
        for(int i = 0; i < 32; i++){
            int bitSum = 0; // 当前位的和
            for(int num : nums){
                bitSum += (num >> i) & 1;
            }
            // (bitSum % REPEAT)的结果为0或1，故也可以不加判断：ans += (bitSum % REPEAT) << i;
            ans += bitSum % REPEAT == 1 ? 1 << i : 0; 
        }
        return ans;
    }
}
```

<br />

## 解法三：逻辑电路

### 算法描述

若题目改为除ans出现一次外其他数均出现两次，那么可以根据异或运算的特点，返回所有数异或的结果。因为相同的数异或得0，而ans^0 = ans。现在来思考异或运算能够解决上述问题的原因，实际上我们希望得到某种运算，该运算跟踪并记录num的出现次数，并希望出现两次时等同于初始未出现状态。于是定义未出现时状态为0，出现一次时，状态从0变为1，再次出现时状态从1变为0，只有两个状态相互间的转换，而异或运算刚好能够表现这样的状态转移过程。本题不同之处在于ans以外的数均出现三次，仍按照状态转移思考，未出现时为0，出现一次，状态从0到1，出现两次，状态从1到2，出现三次，状态回到初始，即从2到0。



如果学习过数字电路课程，我们将看出这是一个逻辑电路设计的问题。我们希望在遍历num的过程中直接对num进行位的逻辑运算，且同一位的根据该位出现1的次数不断重复0 > 1 > 2 > 0的状态变化。例如nums = {7,7,5,5,7,2,5}写成二进制数{111,111,101,101,111,010,101}。遍历该nums，我们希望有一个int res，像下面那样同时记录所有位的状态变化。

```
读取第一个7时，res状态变化：
[0,0,0] > [1,1,1]，
读取第二个7时，res状态变化：
[1,1,1]变为[2,2,2]，
读取第一个5时，res状态变化：
[2,2,2]变为[0,2,0]，
读取第二个5时，res状态变化：
[0,2,0]变为[1,2,1]，
读取第三个7时，res状态变化：
[1,2,1]变为[2,0,2]，
读取2时，res状态变化：
[2,0,2]变为[2,1,2]，
读取第三个5时，res状态变化：
[2,1,2]变为[0,1,0]
====> 最终得到ans = 2
```

三种状态应该由两个比特表示，用a、b、num_i表示如下，ab为状态表示，num_i表示num的二进制表示中的第i位。由状态变化得到如下真值表。

```
a b num_i a b
0 0  0 >  0 0 // #1
0 0  1 >  0 1 // #2
0 1  0 >  0 1 // #3
0 1  1 >  1 0 // #4
1 0  0 >  1 0 // #5
1 0  1 >  0 0 // #6
```

遍历过程的运算将涉及a、b、num，运算的结果将反复更新a、b。根据 #4、#5推导a的变化，根据#2、#3推导b的变化。

```
a = (~a & b & num_i) | (a & ~b & ~num_i)
b = (~a & ~b & num_i) | (~a & b & ~num_i);
```

遍历结束时应该返回什么呢？遍历过程中ab同时计算了所有位的状态变化，只看某一位，ab记录了该位的状态变化0>1>2>0，遍历结束后，不考虑ans，则该位一定是经历了3*k次变化回到状态0，k为出现三次的不同数字的个数。考虑ans，那么ans在该位上会再出现一次，使得ab为00或者01（取决于ans在该位为0或1）。总之ab最终状态要么为00，要么为01，相当于b记录了ans，因此最终返回b。



最后，前述逻辑函数可以简化。首先化简b。

```
b = (~a & ~b & num_i) | (~a & b & ~num_i);
化简
b = ~a & ((~b & num_i) | (b & ~num_i));
b = ~a & (b ^ num_i)
```

若在前述真值表中，每次b更新后都作为下一个ab状态中的b，则有如下对应。

```
a 新b num_i a 
0 0  0 >  0  // #1
0 1  1 >  0  // #2
0 1  0 >  0  // #3
0 0  1 >  1  // #4
1 0  0 >  1  // #5
1 0  1 >  0  // #6
```

通过#4, #5得到a的逻辑函数并化简：

```
a = (~a & ~b & num_i) | (a & ~b & ~num_i)
化简：
a = (~b & ~a & num_i) | (~b & a & ~num_i)
a = ~b & ((~a & num_i) | (a & ~num_i))
a = ~b & (a ^ num_i)
```

最终

```
b = ~a & (b ^ num_i)
a = ~b & (a ^ num_i)
```

<br />

### 时空复杂度

时间复杂度：O(1)

空间复杂度：O(1)

<br />

### 代码

```java
// 化简后
class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for(int num : nums){
            b = ~a & (b ^ num);
            a = ~b & (a ^ num);
        }
        return b;
    }
}
// 化简前for中的语句为
int tmpA = (~a & b & num) | (a & ~b & ~num);
b = ~a & (b ^ num);
a = tmpA;
```

