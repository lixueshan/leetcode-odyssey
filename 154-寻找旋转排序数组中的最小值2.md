# 154-寻找旋转排序数组中的最小值2

[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) (困难)

<br />

***

若想了解更全面的「二分查找」内容，推荐阅读我写的这篇热门文章 [二分查找从入门到入睡](https://leetcode.cn/circle/discuss/ooxfo8/) 。全文两万余字，外科手术式地细致分析了二分查找四种常见模版，全面探讨了二分查找中涉及的各方面问题。

 **该文推出后在力扣热门榜上持续上榜一个多月，两个月内即达成数万阅读量数千收藏及数百点赞，欢迎各位参考指正！** 

***



## 解法一：二分查找

### 算法描述

本题是 [153. 寻找旋转排序数组中的最小值 (题解)](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/-by-yukiyama-rdkj/) 的变形，与 153 题的不同处在与元素大小可以相等 (建议先完成 153 题)。因此我们无法通过 $nums[c]$ 与 $nums[0]$ 或与 $nums[n - 1]$ 的比较来确定地更新 $l$ 和 $r$，这一点很容易通过下图看出来，当 $c$ 位于如下两侧的时候 $nums[c]$ 相等，如果是左边的情形，应该更新 $l$ ，如果是右边的情形，应该更新 $r$，但现在无法确定了。总之这个特点使得我们没法简单套用模版，但不要紧，只要找到「循环不变」关系即可。


![image.png](https://pic.leetcode-cn.com/1654409320-dYYLRS-image.png)

先罗列容易看出的事实：

1. $nums[0] >= nums[n - 1]$ ，如果 $nums[0] < nums[n - 1]$ ，说明此数组经过旋转回到了未旋转时的状态，即单调状态。
2. 最小值左右侧元素都必大于等于该元素。

从第 2 点来看，我们至少有这两个循环不变关系，若 $nums[c] > nums[n - 1]$ ，则 $c$ 位于第一个区间，更新 $l = c + 1$ ；若 $nums[c] < nums[n - 1]$ ， 则 $c$ 位于第二个区间，更新 $r = c$ 。进入这两个分支，我们将能够将搜索空间减小一半。$r$ 的更新写成 $r = c$ 是因为当 $c$ 恰好是最小值下标且 $nums[c] < nums[n - 1]$ 时，若 $r = c - 1$，我们将会跳过最小值，不便于返回，因此写成类似「模版二」的形式，使得查找结束时 $r$ 为最小值下标（ $l = r$ ，返回 $nums[l]$ 也一样）。这里你可以看出虽然我们总说二分问题采用任意模版总能够解决，但针对具体问题某个模版可能会更「趁手」。

现在还差一种情况，即 $nums[c] == nums[n - 1]$ ，如前所述，此种情形我们无法做到减小一半空间，但必须更新 $l$ 或 $r$ 使得我们总是能够缩小搜索空间来逼近目标，比如可以收缩一位，$l++$ 或者 $r--$ 。尝试寻找这个分支的「循环不变」关系。经过仔细思考，我们发现对于 $nums[c] == nums[n - 1]$ ，无论是 $l++$ 还是 $r--$ 均不可行，问题还是出在元素可以相等上。例如通过前两个分支，此时 $c$ 恰好是最小值下标。而下一次循环有可能通过该分支前进 ($l++$) 或后退 ($r--$) 一位而错过该正确下标。例如 $nums = \{2,1,2,2\}$ ，第一次进入 $while$ 使得 $r$ 更新为 $r = c = 1$，恰好是最小值下标，下一次进入 $while$ 时 $c=0$ ， $nums[c] = nums[0] = 2 = nums[n - 1] = 2$ ，无论是 $l++$ 还是 $r--$ ，都会错过最小值。

调整分支的条件的一个想法是，不再与固定的 $nums[n - 1]$ 比较，而是与 $nums[r]$ 和 $nums[l]$ 比较，这么做的道理在于 $nums[l]$ 始终为第一个单调区间的最小值，$nums[r]$ 始终保持为第二个单调区间的最大值，利用这个特点，可以维持「循环不变」，即前两个分支变为：

```java
if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的 l 的左侧
else if(nums[c] < nums[l]) r = c; // 最小值不在更新后的 r 的右侧
```

我们知道一定有 $nums[l] >= nums[r]$ ，所以第三个分支仅剩下 $nums[c] == nums[l] == nums[r]$ 这一种可能，其循环不变关系需要仔细推敲。因为 $nums[c] == nums[r]$ ：

- 如果此时 $c == r$，说明 $l == c == r$，即这是最后一次更新，$nums[l] == nums[r]$ 就是最小值。
- 如果 $c < r$，说明 $nums[c]$ 是比 $nums[r]$ 更靠左的可能的最小值，因此可以不用考虑 $nums[r]$ 。

也就是说，这个分支可以用来更新 $r$ ，即 $r--$ ，且不会出现我们前面所分析的错过最小值的情况。至此我们得到了完整的代码。同样地，我们可以加一个特判用以对旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字时做快速地判断返回，实际上不用这个特判也是可以的，因为如果是未旋转状态，那么会一直执行 $r--$ ，直到 $l = r = 0$ ，此时返回 $nums[l]$ 恰好是正确的，$nums$ 只有一个元素的情况也同理。还需要注意的是，虽然看起来像「模版二」，但 $r$ 的初始值为 $r = n - 1$，这是因为 $if$ 判断中有 $nums[r]$ ，$r = n$ 时越界。

<br />

### 时空复杂度

时间复杂度：$O(logn)$

空间复杂度：$O(1)$

<br />

### 代码

```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1; // 注意 r 的取值
        if(nums[0] < nums[n - 1] || n == 1) return nums[0]; // 旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字，此行可省略
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的 l 的左侧
            else if(nums[c] < nums[l]) r = c; // 最小值不在更新后的 r 的右侧
            else r--; 
        }
        return nums[l]; 
    }
}
```

<br />

