# 269-火星词典

[269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) (困难)

<br />

## 解法一：拓扑排序

### 算法描述

读题后不难感觉到是个拓扑排序题，于是开始构思如何建图。显然单个字符是顶点，而边的关系蕴含在单词顺序中。先给出关于边的结论，边仅由相邻单词 $w1$ 和 $w2$ 的 **「第一对同下标相异字符」** 给出。例如根据按照词典序排放的相邻单词 $word$ 和 $world$ ，可以找到一条边，即「第一对同下标相异字符」 $d$ 和 $l$ ， $d$ 指向 $l$ （ $d$ 的字典序先于 $l$ ）。那么对于有 $n$ 个单词的 $words$ 字符串数组，因为有 $n-1$ 对相邻单词，所以最多能够构成一张具有 $n-1$ 条边的图。

**我们的目标是根据上述理解构建以字符为顶点，以字符字典序为边的图，然后输出这张图的拓扑排序结果。**  实际上我们现在还不知道哪些字符应该作为图上的顶点，比如是否要将所有出现的字符都作为顶点，还是只将决定了边的字符作为顶点。这是需要根据题意，甚至是一些测试例子来分析得到的。

<br />

#### 情形分析

现在分析一些特殊情形。

**情形一： $w1$ 是 $w2$ 的前缀。**

也就是题目描述中提到的如下:
> 如果前面 $min(s.length, t.length)$ 字母都相同，那么 $s.length < t.length$ 时，$s$ 的字典顺序也小于 $t$ 。

这种情况下 $s$ 和 $t$ 这两个单词无法确定任何一条边，但却是合法的，并且 $s$ 的字典顺序小于 $t$ 。实际例子是 `["ab","abc"]` ，将会输出 `"abc"` 。尽管没有边存在，但拓扑排序后仍会输出所有出现过的字符，这表示我们应该将 **所有字符** 都作为图的顶点。那么最终的图可能是 **不连通**  的，比如前面的例子，图由三个独立的顶点 $a,b,c$ 构成。由于入度都是 0，经过拓扑排序后会输出 `"abc"` 。这是按 **字符出现顺序** 输出的结果，因为无法确定他们之间的字典序，所以 **任意排列都是合法的输出** 。

**情形二： $w2$ 是 $w1$ 的前缀**

例如 `["abc","ab"]` ，同样无边的关系，虽然题目中没有特别强调，但按照正常的词典逻辑， **这种顺序显然是非法的** 。因此在找边建图过程中检测到这种情形，可直接返回空串。

**情形三：不属于任何边的孤立顶点**

例如 `["zx","zy"]` ，确定了一条从 $x$ 到 $y$ 的边，且图只有一条边， $z$ 是一个孤立顶点。因为该输入合法，所以输出结果要包含所有字符。实际上在情形一中也提到了，只需要将 $z$ 也作为图的顶点即可。在拓扑排序时，因为 $z$ 的入度为0，会被提前输出到结果中。根据题目要求，输出结果只需要保证 $x$ 在 $y$ 之前即可，$z$ 的位置是任意的。

**情形四：有圈图**

题目的示例三 `["z","x","z"]` 表明，当图是一个圈时，返回 **空串** 。这里想强调的是，不光是圈图非法，只要有圈就视作非法输入，需要返回空串。例如`["w","z","x","z"]` ，按照拓扑排序，结果是 `"z"` ，但因为存在圈，这个输入视作非法，**正确的结果是返回空串** 。

<br />

#### 解法总结

有了上述分析，实际上这题就是个简单题了，在找边时判断是否为情形二的非法输入，非法则直接返回空串，合法则将所有字符视作有效顶点，且初始入度为 0 。常规建图，常规拓扑排序，只是需要再做一下圈检测，图有圈则输入非法，返回空串。

虽然建图和初始化入度可以在一个方法内完成。但考虑确定边的同时，对输入进行非法检测，若非法，则无需再确定入度和建图了。并且从可读性上来说，把确定边和初始化入度分开写更好。

```markdown
1. 建图 & 初始化入度。
1.1 确定边。遍历words，根据每一对相邻单词的「第一对同下标相异字符」确定边。
1.2 上述过程会对words进行非法检测，若出现情形二的非法相邻单词，
    上述方法中会令类字段invalidInput为true。此处判断一下该字段，非法则直接返回空串。
1.3 初始化入度（也即确定顶点）。遍历words，将每一个不重复字符的入度置为0，
    其他为-1.（因此入度为0的字符即图的顶点）根据边建图。
2. 拓扑排序。排序过程中利用排序顶点数和总顶点数关系，判断是否有环。
    无环图所有顶点都将排序，故若排序数不等于顶点总数，则有环。
```

<br />

### 时空复杂度

时间复杂度：$O(n*L+∣Σ∣)$  $n$ 是单词个数，$L$ 是单词平均长度。构建图最多需要遍历每一个单词，时间复杂度为 $O(n*L)$ 。 $|Σ|$ 是字典中字母数，对应图中顶点数。拓扑排序时间复杂度为 $O(n + |Σ|)$。

空间复杂度：$O(n+∣Σ∣)$ ，取决于图所需的存储空间，即顶点数和边数。

<br />

### 代码

```java
class Solution {
    public String alienOrder(String[] words) {
        int n = words.length, V_NUM = 26;
        int[] indegree = new int[V_NUM]; // 入度
        Arrays.fill(indegree, -1);
        for(String word : words) { // 初始化入度，值为0表示顶点，-1表示非顶点
            char[] chs = word.toCharArray();
            for(char ch : chs) indegree[ch - 'a'] = 0;
        }
        List<List<Integer>> graph = new ArrayList<>(); // 邻接表
        for(int i = 0; i < V_NUM; i++) graph.add(new ArrayList<>());
        for(int i = 0; i < n - 1; i++){ // 构建indgree和graph
            String w1 = words[i], w2 = words[i + 1];
            char[] chs1 = w1.toCharArray(), chs2 = w2.toCharArray();
            int w1n = w1.length(), w2n = w2.length();
            int wn = w1n < w2n ? w1n : w2n, j = 0;            
            for(; j < wn; j++){
                int u = chs1[j] - 'a', v = chs2[j] - 'a'; // u > v
                if(u != v) {
                    graph.get(u).add(v);
                    indegree[v]++; 
                    break; // 一对相邻单词最多决定一条边，处理这条边后直接break
                }
            }
            if(j == wn && w1n > w2n) return ""; // word2为word1的真前缀，非法输入
        }
        return topoSort(graph, indegree);
    }
    // 拓扑排序，排序过程中判断图是否有圈
    private String topoSort(List<List<Integer>> graph, int[] indegree){
        StringBuilder sb = new StringBuilder();
        Queue<Integer> q = new ArrayDeque<>();
        int count = 0, vNum = 0; // 拓扑排序计数 & 图中总节点数
        for(int i = 0; i < indegree.length; i++){ // 将入度为0的顶点加入q中
            if(indegree[i] != -1) {
                vNum++; // 存在
                if(indegree[i] == 0){ // 存在且入度为0
                    q.add(i);
                    sb.append((char) (i + 'a')); // 入度为0的顶点先输出
                    count++; // 排序一个计数一个
                }
            }
        }
        while(!q.isEmpty()){ // 拓扑排序
            int u = q.remove();
            for(int v : graph.get(u)){
                indegree[v]--;
                if(indegree[v] == 0){
                    q.add(v);
                    sb.append((char) (v + 'a'));
                    count++; // 排序一个计数一个
                }
            }
        }
        return count != vNum ? "" : sb.toString(); // 判断是否有圈
    }
}
```

<br />

