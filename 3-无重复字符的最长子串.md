# 3-无重复字符的最长子串

[leetcode 3-无重复字符的最长子串 (中等)](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> **提示：**
>
> - `0 <= s.length <= 5 * 104`
> - `s` 由英文字母、数字、符号和空格组成



## 解法一：暴力搜索

### 算法描述

用两个循环，遍历所有子串可能，维护一个int max实时更新。每得到一个子串，调用`boolean noRepeat()`方法来判断该子串是否有重复字符，如无，则更新max。

### 时空复杂度

时间复杂度：两个for加上每次noRpeat调用，整体为O(n^3)复杂度。

空间复杂度：在noRpeat中维护了一个HashSet，最大不超过字符串字符总数n或字符集大小m，为O(max(n,m))。

### 代码

```java
public int lengthOfLongestSubstringBrute(String s) {
    int max = 0;
    for (int i = 0; i < s.length(); i++) {
        for (int j = i + 1; j <= s.length(); j++) {
            if(noRepeat(s, i, j)){
                max = Math.max(max, j - i);
            }
        }
    }
    return max;
}

private boolean noRepeat(String s, int start, int end) {
    Set<Character> set = new HashSet<>();
    for (int i = start; i < end; i++) {
        char ch = s.charAt(i);
        if(set.contains(ch)) {
            return false;
        }
        set.add(ch);
    }
    return true;
}
```



## 解法二：动态调整当前无重复字符最长子串

### 算法描述

String max保存结果，String tmp保存当前扫描的最长无重复子串。 从左到右扫描，每扫描一个字符(current)，检查tmp是否包含，若包含则截断tmp，例如对于字符串"abcabc"，扫描到第二个a时tmp为"abc"，则此时要截断tmp，并将新扫描的a加入tmp，令tmp为“bca”。 若tmp不包含current，则将current加入tmp，比较tmp和max并更新max扫描结束时max的长度即为结果

### 时空复杂度

时间复杂度：循环一遍即可完成，但每次遇到重复字符更新tmp时，如下语句调用了String的indexOf方法搜索指定字符第一次出现的位置，该方法是O(n)效率的。所以总体为O(n^2)

`tmp = tmp.substring(tmp.indexOf(current) + 1) + current;`

空间复杂度：只用到了常数个变量，为O(1)。

### 代码

```java
public int lengthOfLongestSubstringDynamic(String s) {
    String tmp = "";
    String max = "";
    for (int i = 0; i < s.length(); i++) {
        String current = String.valueOf(s.charAt(i));
        if(!tmp.contains(current)) {
            tmp += current;
            // 更新max
            if(tmp.length() > max.length()) {
                max = tmp;
            }
        }
        else {
            // 若存在重复字符，则从首次出现该字符的后一位截断当前的tmp
            tmp = tmp.substring(tmp.indexOf(current) + 1) + current;
        }
    }
    return max.length();
}
```



## 解法三：HashSet + 滑动窗口

### 算法描述

设置初始值为0的int max，以一个HashSet tmp保存当前不重复子串的所有字符。从左到右遍历字符串s，考察当前读取到的字符current，判断tmp中是否包含current，若不包含，则加入current，并比较当前max和tmp.size()，更新max。若包含，则移动窗口，如字符串`abcbd`，窗口从a到ac到abc，此时处理到第二个b，则窗口要移动到第一个b之后，即当前(abc)bd，处理完第二个b后窗口变为ab(cb)d，括号为窗口。做法是遇到重复字符时，从当前最大不重复子串起始位置currentStart开始删除字符， 直到将重复字符删除。每次删除重复字符后要更新当前currentStart，并将冲突的currentChar加入tmp中。

### 时空复杂度

时间复杂度：只需要扫描一次，最坏情形为最后两个字符重复，则set中要将整个字符串遍历一遍以移除重复字符串前的所有字符，为O(2n)，最终写为O(n)形式。

空间复杂度：用到了HashSet，为O(max(n,m))，n是字符串长度，m是字符集大小。

### 代码

```java
public int lengthOfLongestSubstringWindow(String s) {
    int max = 0; // 用于实时更新最大值
    int currentStart = 0; // 当前不重复子串的起始下标
    Set<Character> tmp = new HashSet<>();

    for (int i = 0; i < s.length(); i++) {
        char currentChar = s.charAt(i);
        if(!tmp.contains(currentChar)) {
            tmp.add(currentChar);
            // 更新max
            if(tmp.size() > max) {
                max = tmp.size();
            }
        }
        else {
            int j = currentStart;
            // 如果tmp包含current，要从当前子串开始处移除tmp中的字符，直到将current也移除
            while(tmp.contains(currentChar)) {
                tmp.remove(s.charAt(j++));
            }
            currentStart = j; // 更新当前最大不重复子串的起点
            tmp.add(currentChar); // 移除后要加回来，相当于窗口发生移动，例如从(abc)bd移动为ab(cb)d
        }
    }
    return max;
}
```



## 解法四：HashMap + 跳跃式滑动窗口

### 算法描述

在解法三思路的基础上，遇到一个字符，若不重复，将字符本身连同下标都保存到HashMap中， 重复时，就可以以此字符为key在当前map中找到其value，即该字符第一次出现在s中的下标，用这个下标直接更新窗口左界，实现跳跃式窗口滑动。从而时间复杂度会用set的解法的O(2n)优化到为O(n)。

### 时空复杂度

时间复杂度：如上述分析，为O(n)。

空间复杂度：用到了HashSMap，为O(max(n,m))，n是字符串长度，m是字符集大小。

### 代码

```java
public int lengthOfLongestSubstringWindowJump(String s) {
    int max = 0; // 用于实时更新最大值
    int leftIdx = 0; // 当前不重复子串的起始下标
    Map<Character, Integer> map = new HashMap<>();

    for (int rightIdx = 0; rightIdx < s.length(); rightIdx++) {
        char currentChar = s.charAt(rightIdx);
        // 遇到重复字符，将leftIdx设置为当前leftIdx和map中保存的上一次出现的该字符的下标+1
        if(map.containsKey(currentChar)) {
            leftIdx = Math.max(leftIdx, map.get(currentChar)+1);
        }
        // 对于不重复的字符，总是保存该字符及其下标
        map.put(currentChar, rightIdx);
        max = Math.max(max, rightIdx - leftIdx + 1);
    }
    return max;
}
```



## 解法五：数组 + 跳跃式滑动窗口

### 算法描述

根据题目提示，输入字符串只会英文字母，数字，符号和空格。显然是ASCII码能够覆盖的范围，所以最大不重复子串最多只有128个。可以用长度128的数组int[] index来保存字符在s中的下标，减少哈希函数计算的开销。扫描过程中在index中保存不重复的字符，用于识别该字符的信息为其在index数组中的下标， 例如在输入字符的下标3处遇到字符'a'，令index[96] = 3 ('a'的值为96)。

由于对下标0的字符保存为0，在通过index[currentChar] != 0判断是否是重复字符时产生干扰，所以统一将保存的下标都加1。要小心处理下标。

### 时空复杂度

时间复杂度：与哈希表法相同，O(n)，但由于节省了哈希函数的计算开销，优于哈希表法。

空间复杂度：用到了字符集大小的数组，为O(max(n,m))，n是字符串长度，m是字符集大小。

### 代码

```java
public int lengthOfLongestSubstringWindowJumpArray(String s) {
    int max = 0; // 用于实时更新最大值
    int leftIdx = 1; // 当前不重复子串的起始下标，注意是从1开始的
    int[] index = new int[128]; // 初始时

    for (int rightIdx = 0; rightIdx < s.length(); rightIdx++) {
        char currentChar = s.charAt(rightIdx);
        // 遇到重复字符，将leftIdx设置为当前leftIdx和map中保存的上一次出现的该字符的下标+1
        if(index[currentChar] != 0) {
            leftIdx = Math.max(leftIdx, index[currentChar]+1);
        }
        // 对于不重复的字符，总是保存该字符的下标(+1)
        index[currentChar] = rightIdx + 1; // 注意要加1
        max = Math.max(max, (rightIdx + 1) - leftIdx + 1); // 注意rightIdx要加1
    }
    return max;
}
```



## 延伸：返回无重复字符的最长子串

如果题目要求的是以String类型返回无重复字符的最长子串，在前述解法代码中做少量必要调整即可。比如维护当前最大子串在s中的起始下标start和结束下标end，程序结束前返回s.subString(start, end)即可。

例: “动态调整当前无重复字符最长子串”解法中，直接返回max本身即可。

```java
public String lengthOfLongestSubstringDynamic(String s) {
    String tmp = "";
    String max = "";
    for (int i = 0; i < s.length(); i++) {
        String current = String.valueOf(s.charAt(i));
        if(!tmp.contains(current)) {
            tmp += current;
            // 更新max
            if(tmp.length() > max.length()) {
                max = tmp;
            }
        }
        else {
            // 若存在重复字符，则从首次出现该字符的后一位截断当前的tmp
            tmp = tmp.substring(tmp.indexOf(current) + 1) + current;
        }
    }
    return max;
}
```



例: 对“HashSet + 滑动窗口”解法稍加改造，可以有如下做法。

```java
public String lengthOfLongestSubstringGetString(String s) {
    int currentStart = 0;
    String maxSubString = ""; 
    StringBuilder sb = new StringBuilder(""); // 保存当前最大不重复子串sb
    Set<Character> tmp = new HashSet<>();

    for (int i = 0; i < s.length(); i++) {
        char currentChar = s.charAt(i);
        if(!tmp.contains(currentChar)) {
            tmp.add(currentChar);
            sb.append(currentChar); // 加入当前字符到sb
            if(tmp.size() > maxSubString.length()) {
                maxSubString = sb.toString(); // 更新最大不重复子串
            }
        }
        else {
            int j = currentStart;
            // 如果tmp包含current，要从当前子串开始处移除tmp中的字符，直到将current也移除
            while(tmp.contains(currentChar)) {
                tmp.remove(s.charAt(j++));
                sb.delete(0, 1); // sb也相应从头部开始缩减
            }
            currentStart = j; // 更新当前最大不重复子串的起点
            sb.append(currentChar); // 移除后要加回来，相当于窗口发生移动，例如从(abc)bd移动为ab(cb)d
            tmp.add(currentChar); // 目的同上一行
        }
    }
    return maxSubString.toString();
}
```

