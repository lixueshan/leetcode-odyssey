# 300-最长递增子序列

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) (中等)

<br />

## 解法一：动态规划

### 算法描述

定义 $dp$ 数组， $dp[i]$ 表示下标 $nums[i]$ 作为最长上升子序列最后一个数时，该最长上升子序列的长度。

边界: $dp[i] = 1$ 每个数字作为一个序列，长度为1。

递推: $dp[i] = max(dp[i], dp[j] + 1)$  $(nums[j] > nums[i])$  。表示 $dp[i]$ 是由其前面的所有最长上升子序列所共同决定的，即在 $nums[i]$ 之前有 $nums[j]$ 满足 $nums[j] < nums[i]$ ，则 $dp[i] = dp[j] + 1$，从 $nums[0]$ 遍历到 $nums[i - 1]$ ，当满足前述条件时尝试更新 $dp[i]$ ，则遍历过后得到最终的 $dp[i]$ 。设置一全局的 $max$ ，每确定一个 $dp[i]$ ，就以其更新 $max$ 。 

<br />

### 时空复杂度

时间复杂度：$O(n^2)$

空间复杂度：$O(n)$

<br />

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length, max = 1;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){ // 此for过后得到的dp[i]为以nums[i]为尾元素的最长上升子序列长度
                if(nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            max = Math.max(dp[i], max);
        }
        return max;
    }
}
```

<br />

## 解法二：贪心+二分查找

### 算法描述

首先证明如下

定义 `d[i]` : 长度为 `i` 的最长上升子序列可以有很多个，在这些子序列中末尾元素最小值，记作 `d[i]`。

`d[i]` 严格单调递增性质: 对于 `i < j` 必有 `d[i] < d[j]` 。通俗地说就是 $nums$ 中存在若干长度为 $i$ 的递增子序列，其中末尾元素最小的是 $A$ 子序列，其末尾元素是 $nums[i]$ ；$nums$ 中也存在若干长度为 $j$ 的递增子序列，其中末尾元素最小的是 $B$ 子序列，其末尾元素是  $nums[j]$ 。如果 $i < j$ ，则必有 $nums[i] < nums[j]$ 。

反证法: 假设 `d[i]` 不具有严格单调递增性质，也就是说存在 `i < j` ，但是 `d[i] ≥ d[j]` 。
- 首先，`d[i]` 和 `d[j]` 所对应的长度分别为 `i` 和 `j` 的上升子序列，其内部是严格单调递增的 (这是题目对「最长递增子序列」的定义)。
- 我们定义里说过，`d[i]` 表示的是长度为 `i` 的递增子序列中，最小的末尾元素。如果通过前述假设，能够构造一个长度为 `i` 的严格递增序列，但它的末尾元素比 `d[i]`  还要小，假设这个末尾元素是 `t`，满足 `t < d[i]` ，那么就存在一个长度为 `i` ，但末尾元素比 `d[i]` 还要小，那么开始的假设就不成立。下面开始构造。
- 构造：从 `d[j]` 所在的序列中减去末尾 `j - i` 个元素，那么剩下的子序列 (仍然是严格单调递增的序列) 的长度是 `i`。记它的末尾元素为 `t`，那么必然有 `t < d[j] ≤ d[i]`，于是这个长度为 `i` 的序列的末尾元素，比 `d[i]` 要小，与 `d[i]` 的定义矛盾。
- 因此在 `d[i]` 的定义下，假设不成立，即 `d[i]` 具有严格单调递增性质。

寻找「最大递增子序列」的过程如下：

- 设置一个用于拼接最大递增子序列的数组 $maxSeq$ 。初始时 $masSeq$ 大小与 $nums$ 大小相同， 并令 $maxSeq[0] = nums[0]$ ，最大递增子序列的长度为 $len = 1$ 。
- 从 $nums[1]$ 开始遍历 $nums$ ，比较 $maxSeq[len - 1]$ (当前得到的最长递增子序列的末尾元素) 与 $nums[i]$ 的大小。
  - 情形1: 如果 $nums[i]$ 较大，则 $maxSeq[len] = nums[i]$ ，令 $len++$ 。 
  - 情形2: 否则，根据前述的 $d[i]$ 的性质，更长的递增子序列，末尾元素会更大，为了找到更长的递增子序列，需要确保当前长度的递增子序列的末尾元素是该长度下所有递增子序列中最小的，这样才不会错过任何一个能够贡献长度的元素。

对于上述过程的情形2，有点不好理解，我们举例说明。例如 $\{3,5,10,6,7\}$，按照前述说明，遍历到 10 后得到  $\{3,5,10\}$ ，如果我们不执行情形2的操作，那么只能得到 $\{3,5,10\}$ 这一结果，显然是错误的。而如果我们在遍历 6 的时候，用它替换掉刚好比它小的数 5 的下一个数，那么我们将得到 $\{3,5,6\}$ 。通过这样的操作，我们得到了长度为 3 的的递增子序列中，末尾元素最小 (6<10) 的那个序列，因为它末尾元素 6 更小，因此它相比 10 ，**接受后续数字构成更长递增子序列的机会更大**。遍历到 7 的时候，就可以将 7 拼接在 6 后面，于是就得到了正确的结果 $\{3,5,6,7\}$ 。

由于 $maxSeq$ 是单调递增的，因此在寻找 $maxSeq$ 中刚好小于 $nums[i]$ 的数时，可以用二分查找的方法。

<br />

### 时空复杂度

时间复杂度：遍历为 $O(n)$ ，二分查找需要 $O(logn)$，综合为 $O(nlogn)$。

空间复杂度：$O(n)$

<br />

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length, len = 1;
        int[] maxSeq = new int[n];
        maxSeq[0] = nums[0];
        for(int i = 1; i < n; i++){
            if(maxSeq[len - 1] < nums[i]){
                maxSeq[len] = nums[i];
                len++;
            } else {
                int pos = findPos(maxSeq, len, nums[i]);
                maxSeq[pos] = nums[i];
            }
        }
        return len;
    }
    private int findPos(int[] nums, int r, int target){
        int l = 0;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c - 1;
        }
        return l;
    }
}
```

<br />



