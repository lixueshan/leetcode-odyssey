若正在阅读本篇题解的你还未掌握线段树，推荐阅读我创作的 [线段树 (树ADT连载 11/13)](https://leetcode.cn/circle/discuss/H4aMOn/) ，全文两万余字，从最基本的概念讲起，全面并详细涉及以下内容，给出八种完整的线段树类代码实现。读完并理解后可解决力扣上几乎所有线段树题目，欢迎大家阅读指正。

> 基本静态线段树 / 完全二叉树下标性质 / 分治算法 / 懒惰标记 / 延迟修改 / 离散化 / 强制在线 / 动态开点线段树 / 结点数组法动态开点 (预估结点数) / 结点指针法动态开点 

***

# 307-区域和检索 - 数组可修改

[307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) (中等)

<br />

## 解法一：树状数组

### 算法描述

本题可用标准的 **单点修改区间查询版本的树状数组 (PURQ BIT)** 解决。关于树状数组，我在 [树状数组(先行版)](https://leetcode.cn/circle/discuss/qGREiN/) 这篇文章中做了详细介绍，阅读完这篇文章，可轻松解决本题。

<br />

### 时空复杂度

时间复杂度：构建树状数组 $O(nlogn)$ ，$n$ 为 $nums$ 的大小。单点修改和区间查询均为 $O(logn)$ 。

空间复杂度： $O(n)$

<br />

### 代码

```java
class NumArray {
    BIT bit;
    int[] nums;
    public NumArray(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        this.bit = new BIT(n);
        for(int i = 0; i < n; i++){
            bit.add(i + 1, nums[i]);
        }
    }
    public void update(int index, int val) {
        bit.add(index + 1, val - nums[index]);
        nums[index] = val;
    }
    public int sumRange(int left, int right) {
        return bit.query(right + 1) - bit.query(left);
    }
}
class BIT{
    int n;
    int[] tree;
    public BIT(int n){
        this.n = n;
        this.tree = new int[n + 1];
    }
    public int query(int k){
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){
            ans += tree[i];
        }
        return ans;
    }
    public void add(int k, int x){
        for(int i = k; i <= n; i += lowbit(i)){
            tree[i] += x;
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}
```

<br />

## 解法二：线段树

### 算法描述

本题可用简单的支持 **单点修改区间查询版本的线段树** 解决。

<br />

### 时空复杂度

时间复杂度：构建线段树 $O(n)$ ，$n$ 为 $nums$ 的大小。单点修改和区间查询均为 $O(logn)$ 。

空间复杂度： $O(n)$

<br />

### 代码

不维护 $nums$ 的写法。

```java
class NumArray { 
    int n;
    SegmentTree st;
    public NumArray(int[] nums){
        this.n = nums.length;
        this.st = new SegmentTree(nums);
    }
    public void update(int index, int val) {
        st.update(index, val, 0, n - 1, 1);
    }
    public int sumRange(int left, int right) {
        return st.sum(left, right, 0, n - 1, 1);
    }
}
class SegmentTree {
    int[] nums, tree;
    int n;
    public SegmentTree(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        build(0, n - 1, 1);
    }
    public int sum(int l, int r, int s, int t, int i){ // 求区间nums中[l, r]元素之和
        if(l <= s && t <= r) return tree[i]; // 当前结点区间在所求范围之间
        int c = s + (t - s) / 2, sum = 0;
        if(l <= c) sum += sum(l, r, s, c, i * 2); // 递归累加目标区间落在c左侧(含c)的区间和
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1); // 递归累加目标区间落在c右侧的区间和
        return sum;
    }
    public void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] = x;
            return;
        }
        int c = s + (t - s) / 2;
        if(idx <= c) update(idx, x, s, c, i * 2);
        else update(idx, x, c + 1, t, i * 2 + 1);
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
    private void build(int s, int t, int i){ // 构建线段树(tree数组), i: nums当前区间在线段树中的结点下标
        if(s == t) { // s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2); // 左子树的根下标即为原根的左子结点下标 i*2
        build(c + 1, t, i * 2 + 1); // 右子树的根下标即为原根的右子结点下标 i*2+1
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }  
}
```

维护 $nums$ 的写法。

```java
class NumArray { 
    int n;
    int[] nums;
    SegmentTree st;
    public NumArray(int[] nums){
        this.n = nums.length;
        this.nums = nums;
        this.st = new SegmentTree(nums);
    }
    public void update(int index, int val) {
        st.add(index, val - nums[index], 0, n - 1, 1);
        nums[index] = val;
    }
    public int sumRange(int left, int right) {
        return st.sum(left, right, 0, n - 1, 1);
    }
}
class SegmentTree {
    int[] nums, tree;
    int n;
    public SegmentTree(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        build(0, n - 1, 1);
    }
    public int sum(int l, int r, int s, int t, int i){ // 求区间nums中[l, r]元素之和
        if(l <= s && t <= r) return tree[i]; // 当前结点区间在所求范围之间
        int c = s + (t - s) / 2, sum = 0;
        if(l <= c) sum += sum(l, r, s, c, i * 2); // 递归累加目标区间落在c左侧(含c)的区间和
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1); // 递归累加目标区间落在c右侧的区间和
        return sum;
    }
    public void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] += x;
            return;
        }
        int c = s + (t - s) / 2;
        if(idx <= c) add(idx, x, s, c, i * 2);
        else add(idx, x, c + 1, t, i * 2 + 1);
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
    private void build(int s, int t, int i){ // 构建线段树(tree数组), i: nums当前区间在线段树中的结点下标
        if(s == t) { // s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2); // 左子树的根下标即为原根的左子结点下标 i*2
        build(c + 1, t, i * 2 + 1); // 右子树的根下标即为原根的右子结点下标 i*2+1
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }  
}
```

<br />