# 315-计算右侧小于当前元素的个数

[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) (困难)

<br />

## 解法一：归并排序

### 算法描述

归并排序的经典应用，$merge$ 方法与常规归并排序只有一行的差异。只需要理解如何 **在「归并」过程中累计「逆序数」** 即可。对两个排序好的左右数组进行「归并」时，比较左数组的当前数 $nums[l]$ 与右数组的当前数 $nums[r]$ ，若 $nums[r] < nums[l]$ ，说明 $nums[r]$ 与从 $nums[l]$ 开始的，左数组剩余的所有数都构成「逆序对」。于是累计此数量，每次比较左数组当前数与右数组当前数时，都执行此累计。不难发现该累计只发生在 $merge$ 方法的 $nums[r] < nums[l]$ 分支里，因此相比常规的归并排序 $merge$ 方法，仅有一行不同。代码中仅展示「自底向上归并」，其他方式的归并实现类似，仅需在 $merge$ 方法中添加一行逆序数累计语句即可。

<br />

### 时空复杂度

时间复杂度：$O(nlogn)$

空间复杂度：辅助数组空间 $O(n)$

<br />

### 代码

```java
// 自底向上归并
class Solution {
    int count = 0;
    public int reversePairs(int[] nums) {
        if(nums.length < 2) return 0;
        int n = nums.length;
        int[] tmp = new int[n];
        for(int gap = 1; gap < n; gap *= 2){
            for(int l = 0; l < n - gap; l += 2 * gap) {
                // 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;
                merge(nums, tmp, l, l + gap - 1, Math.min(l + 2 * gap - 1, n - 1));
            }
        }
        return count;
    }
    // 非原地合并方法
    private void merge(int[] nums, int[] tmp, int l, int lEnd, int rEnd) {
        int r = lEnd + 1, start = l, cur = l;
        while (l <= lEnd && r <= rEnd) {
            if (nums[l] <= nums[r]) tmp[cur++] = nums[l++];
            else {
                count += lEnd - l + 1; // 与归并排序merge方法仅有此行的差异
                tmp[cur++] = nums[r++];
            }
        }
        while (l <= lEnd) tmp[cur++] = nums[l++]; // 左数组仍有剩余
        while (r <= rEnd) tmp[cur++] = nums[r++]; // 右数组仍有剩余
        for(; start <= rEnd; start++) { // 拷回nums
            nums[start] = tmp[start];
        }
    }
}
```

<br />

## 解法二：树状数组

### 算法描述

本题可以看作是 [剑指 Offer 51. 数组中的逆序对 (题解)](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/) 的树状数组解法的变形题。首先，本题要求给出每一个 $nums[i]$ 的右侧小于它的元素个数。可以先将 $nums$ 反转，问题转换为求每一个 $nums[i]$ ( $nums$ 已反转) 的左侧小于它的元素个数。按顺序求出结果后再反转，即为答案。

如果题目问的是「小于等于」，那么 BIT 类的代码可以一字不改。但本题问的是「小于」，则必须考虑元素相等的情况，因此需要在对 BIT 做一些调整，好在这个调整非常简单。调整的关键如下。

1. 在 BIT 类中以一个 $occurs$ 数组维护每一个元素的出现次数。具体做法是在 $add$ 方法中，每次 $for$ 循环操作前执行 `occurs[k]++` 。
2. 在 BIT 类的 $query$ 方法中，不直接返回「前缀和」，而是返回 `ans - occurs[k]` ，表示对当前数字统计之前出现过的比它小的元素个数时，不累计之前出现过的相同数字。

在 [剑指 Offer 51. 数组中的逆序对 (题解)](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/) 一题解法的基础上，加入上述调整即可，代码非常相似。

<br />

### 时空复杂度

时间复杂度：离散化 $O(nlogn)$，树状数组求解 $O(nlogn)$ ，综合为 $O(nlogn)$ 。渐进时间复杂度与归并排序做法相同，但显然常系数要更大一些。

空间复杂度：$O(n)$

<br />

### 代码

```java
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        int[] arr = discrete(nums); // 离散化nums
        int n = arr.length;
        for(int i = 0; i < n / 2; i++){ // 反转arr
            int tmp = arr[i];
            arr[i] = arr[n - 1 - i];
            arr[n - 1 - i] = tmp;
        }
        BIT bit = new BIT(arr);
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            res.add(bit.query(arr[i]));
            bit.add(arr[i], 1);
        }
        Collections.reverse(res); // 反转
        return res;
    }
    private int[] discrete(int[] nums){ // 离散化
        int n = nums.length;
        int[] tmp = new int[n];
        System.arraycopy(nums, 0, tmp, 0, n);
        Arrays.sort(tmp);
        for (int i = 0; i < n; ++i) {
            nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;
        }
        return nums;
    }
}
class BIT {
    int n;
    int[] tree, occurs;
    public BIT(int[] nums) {
        this.n = nums.length;
        this.tree = new int[n + 1];
        this.occurs = new int[n + 1];
    }
    public int query(int k){ // 查询前k项和
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += tree[i];
        }
        return ans - occurs[k]; // 去掉相等的个数
    }
    public void add(int k, int x){ // 为第k项加上x
        occurs[k]++; // 记录同一个数处理的次数
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            tree[i] += x; 
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}
```

<br />

