# 790-多米诺和托米诺平铺

[790. 多米诺和托米诺平铺](https://leetcode.cn/problems/domino-and-tromino-tiling/) (中等)

<br />

## 解法一：递推式

### 算法描述

本方法容易入手，但推导过程需要细心，联立几个式子得到递推式的过程也需要一些耐心。



如下，记最后一列，即第 $i$ 列全部铺满，也就是从第 1 列到最后一列全部铺满（只表现最后两列），种类数为 $S(i)$

```java
// S(i)
■ ■
■ ■
```

当最后一列不铺，到第 $i - 1$ 列铺满时，种类数显然为 $S(i - 1)$

```java
// 情形1
■ □
■ □
```

现在考虑二者的关系，看起来最后一列只需要（也只能够）垂直插入多米诺瓷砖，就可以得到 $S(i)$ ，那么是 $S(i) = S(i - 1)$ 吗？显然不是，因为 $S(i)$ 不但能从情形1垂直插入多米诺瓷砖得到，也可以由以下情形得到。注意，这里所列的所有铺装图的最后一列均为上述所述的第 i 列。

```java
// 情形2     情形3      情形4        情形5
■ □ □     ■ ■ □     ■ ■ ■     ■ □ □
■ ■ □     ■ □ □     ■ □ □     ■ ■ ■ 
```

于是，考虑「插入最后一块瓷砖」得到 $S(i)$ ，一共有情形 1～5 这五种插法。需要注意的是，「情形4」和「情形5」在「铺装种类数」这一角度上，是同一种情形（插入后在最后两列上没有任何区别，后续将情形4,5合称情形4），且显然其铺装种类数为 $S(i - 2)$ 。另外，「情形2」和「情形3」是不同的。

现在来考虑这四种情形是否互斥，情形1，2，3之间显然互斥，但情形4似乎是情形1的真子集，因为情形4只需要加一条垂直的多米诺就能形成情形1（的一种铺装）。但是，一旦这么做，也就不能再通过最后插入一根横放的多米诺瓷砖来得到最终铺装了。因此四种情形在「铺装种类数」上是完全互斥的，且它们的和即为 $S(i) = S(i - 1) + S(情形2) + S(情形3) + S(i - 2)$ 。

如果能将上述 $S(i)$ 写成若干个 $S(i - x)$ 项相加的形式，$x$ 是确定的数，那么我们就能得到确定的递推式。现在来分析情形2和情形3，继续向前观察。为方便讨论，将如下情形2的铺装种类数记为 $X(i - 1)$，情形3的铺装种类数记为 $Y(i - i)$。记住，最后一列始终是第 $i$ 列，情形2和情形3最后有铺装的列在 $i - 1$ 列。

```java
// 情形2        情形3 
■ ■ □ □     ■ ■ ■ □
■ ■ ■ □     ■ ■ □ □
```

两种情形有相似性，先讨论情形2。要形成情形2倒数第二列上无下有的状态，倒数第二列和倒数第三列要么铺多米诺 `__` （铺在下侧，情形2-1），要么铺托米诺 `L` (情形2-2)，有且仅有这两种可能，为了便于区分，下图只表现 `L`  和 `__`。

```java
// 情形2 - 1   情形2 - 2
□ □ □ □     □ ■ □ □ 
□ ■ ■ □     □ ■ ■ □ 
```

如果是情形2-1，那么实际上是 $Y(i - 2)$ 的铺装再加一块横放的多米诺瓷砖 `__` 。如果是情形2-2，那么就是 $S(i - 3)$ 再加一块托米诺 `L`。且它们是互斥的，于是

$$X(i - 1) = Y(i - 2) + S(i - 3)\tag{1}$$

对情形3进行同样的分析，不难得到

$$Y(i - 1) = X(i - 2) + S(i - 3)\tag{2}$$

前面已知

$$S(i) = S(i - 1) + X(i - 1) + Y(i - 1) + S(i - 2)\tag{3}$$

将 $i$ 换成 $i - 1$就是

$$S(i - 1) = S(i - 2) + X(i - 2) + Y(i - 2) + S(i - 3)\tag{4}$$

下面我们通过对上述式子做简单的运算，导出最终的递推式。

$(4)$ 左右两边加上 $S(i - 3)$

$$S(i - 1) + S(i - 3) = S(i - 2) + X(i - 2) + Y(i - 2) + 2*S(i - 3)\tag{5}$$

$(1)+(2)$ 得到

$$X(i - 1) + Y(i - 1) = X(i - 2) + Y(i - 2) + 2*S(i - 3)\tag{6}$$

$(6)$ 代入 $(5)$

$$S(i - 1) + S(i - 3) = S(i - 2) + X(i - 1) + Y(i - 1)\tag{7}$$

$(3)-(7)$

$$S(i) = 2 * S(i - 1) + S(i - 3)\tag{8}$$

最终代码不难写出。

<br />

### 时空复杂度

时间复杂度：$O(n)$

空间复杂度：$O(1)$

<br />

### 代码

```java
class Solution {
    int MOD = 1_000_000_007;
    public int numTilings(int n) {
        if(n < 3) return n;
        if(n == 3) return 5;
        int n3 = 1, n2 = 2, n1 = 5, ans = 0;
        for(int i = 4; i <= n; i++){
            ans = ((2 * n1) % MOD + n3) % MOD;
            n3 = n2;
            n2 = n1;
            n1 = ans;
        }
        return ans;
    }
}
```

<br />

