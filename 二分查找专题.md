## 二分查找

二分查找以其原理极为简单，但细节处理却极易出错而闻名。在本文中，我将以「循环不变」为中心，讨论两种常见的二分查找实现模版，尝试展示「循环不变」原理如何帮助我们跳出二分的「变化」过程，在「不变」的帮助下准确地理解模版代码的工作过程及其正确性，并在此基础上能够应对各种不同的二分场景写出bug free的代码。



在两个模版的介绍中，我将依次给出「相等返回」情形的写法和四种「一般」情形的写法，所有情形的实现在模版一中都是正确无误的，但在模版二中，同样遵循「循环不变」原则的「一般」写法，若不以正确形式给出，就有可能陷入无限循环。我将仔细证明为何看似正确的代码会陷入无限循环，以及如何通过细微的调整将其修正为正确的的代码。

<br />

### 模版一 (错位终止/左闭右闭)

#### 相等返回情形

以一道最基本的二分查找题目[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)为例开始讲解。最常见的模版一实现的代码如下，实际上这是模版一我称之为「相等返回」的特例，后续给出四种一般情形的模版一代码中，有两种情形能够涵盖「相等返回」。代码中的l、r、c代表搜索空间左界 (left)，右界 (right) 和中间值 (center) 下标。

> 704-二分查找:
>
>  给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
// 模版一「相等返回」写法
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1; 
        while(l <= r){ // 循环条件
            int c = l + (r - l) / 2; // 中间值坐标
            if(nums[c] == target) return c; // 相等返回
            else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧元素「必」大于target 
        }
        return -1; 
    }
}
```

关于求中间值坐标的写法，最简单的写法当然是 c = (l + r) / 2，但直接相加会使得 l + r 大于 2^31-1 (2147483647) 时（提前）溢出，例如 l = 1, r = 2^31-1，计算 c 时， l + r = 2^31 (2147483648) 导致溢出。但原本应该有 c = 1073741824，l, r, c都不应该溢出，只是因为 l + r 导致了（提前）溢出。因此改写成先减后加的形式 c = l + (r - l) / 2。当然很多人会用 >> 代替除法，写成  c = l + ((r - l) >> 1) 也是可以的。值得一提的是JDK中采用的是 c = (l + r) >>> 1的写法。>>> 是无符号右移运算符([Unsigned right shift operator](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html))，与 >> 的区别在于右移的时不考虑符号位，总是从左侧补0，l + r 不溢出的时候符号位本来就是0，与 >> 效果相同。 l + r 溢出时最高位符号位从0进位成了1，经过 >>> 的移位，最高位又变回了0，这是一种利用位运算的trick，可以参考[这里](https://stackoverflow.com/questions/13785210/why-in-java-high-low-2-is-wrong-but-high-low-1-is-not)。



【二分查找趣闻】

Java传奇开发人员Joshua Bloch 2006年在Google任职时写过一篇博文[Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken](https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html)，主要讲的是上面提到的溢出。Joshua Bloch聊了这么几个事。

- 他在CMU刚读博的第一堂算法课上，老师Jon Bentley(「编程珠玑」作者，k-d树法明人)让大家写二分查找，结果大部分人的实现都是错误的。
- 到2006年的时候，Joshua Bloch才知道「编程珠玑」中的二分查找实现存在上述整数溢出的问题，此时距离该书出版已经过去了21年。

- 直到那时，同样的bug在他实现的JDK的binarySearch里也已经存在了9年之久。就因为中间值下标的计算语句是 `int mid =(low + high) / 2;` 。
- 他提出归并排序以及其他一些分治算法都要重新审视是否存在同样的问题。
- Joshua Bloch因此怅然良久，发出了一些bug与我们永存，对待代码要有敬畏之心之类的感慨。

※ Extra, Extra即“号外！号外！”，可见当时Joshua Bloch写这篇文章的时候确实是心有戚戚不吐不快。

<br />

##### 「循环不变」与程序正确性

跟踪循环中变化的细节是困难的，因此我们需要找到一些在整个循环过程中都不会发生变化的「量」或「关系」，以便得到循环结束后某些确定的结论。在这个实现中，  #1和#2两行保证了如下「关系」是「循环不变」的：

1. 对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。
2. 对于#2行，若进入该分支，则 r 下标更新后其右侧元素「必」大于target。

在程序运行过程中，中间值要么等于target直接返回答案，要么执行#1或#2。基于上述两个不变的关系，若执行#1，则更新后的 l 左侧元素为target的可能性被完全排除，若执行#2，则更新后的 r 右侧元素为target的可能性被完全排除。再次强调，这两个「关系」对于更新后任意时刻的 l 和 r 来说都是「不变」的。同时强调的是「更新后」这一前提，因为若target比nums中所有元素都大，则 r 不会经历更新，若target比nums中所有元素都小，则 l 不会经历更新。不经历更新，就不具有前述两条「循环不变」的关系。例如target大于nums中所有元素时，r 不更新，最终r = nums.length - 1，l = nums.length, l 经历过更新，此时说 l 左侧元素必小于target是正确的，但 r 右侧元素必大于target是不成立的（r右侧没有元素）。这一点在「一般」情形中会影响返回时的判断，后续还会说明。不过在这个「相等返回」写法中，显然无需考虑 l, r 是否有过更新。



程序执行过程中的两种情况：

1. 情况一：nums[c] == target，直接返回正确的结果。

2. 情况二：while因 l 与 r 不满足 l <= r 而终止。现在来看循环终止时 l 与 r 的关系。while的每一次执行，要么 l 比 c 的位置右移一位，要么 r 相比当前 c 的位置左移一位，while终止条件为 l > r，通过几个例子很容易推出终止时 l 与 r 的关系「必」为 r = l - 1（见后续「错位终止图示」）。即while终止时，r 与 l 相邻，r 在 l 左侧一位。前述我们已经强调过，对于更新后任意时刻的 l，其左侧元素必不存在target，对于更新后任意时刻的 r，其右侧元素必不存在target。而while终止时 r 的右侧和 l 的左侧正好覆盖了所有nums的元素，此时可以断言：target必不在nums中。若target大于nums中所有元素，虽然 r 不更新，但最终 l 的左侧覆盖了所有元素。同样地，target小于nums中所有元素时，l 虽不更新，但最终 r 的右侧覆盖了所有元素，断言都能够成立。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23kcbdsusj210g04qq3c.jpg" alt="image-20220510200547287" width="500;" />
</div>

至此，通过分析「循环不变」关系，我们明确了上述代码的正确性，并理解了其正确的根本原因。



【错位终止图示】

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h223y8ri4ij20va0lmdho.jpg" alt="image-20220509135307511" width="500;" />
</div>
<br />

【关于命名】

「模版一」、「模版二」是约定俗成的命名，并不必然与某种确定的模式相绑定。但大部分资料，包括本文所述的「模版一」，都是基于「错位终止」而言的，也就是 **while循环结束时一定有 r = l - 1**，这一点是所谓「模版一」的标志 ，故以 **「错位终止」** 强调之。后续介绍的「模版二」， **while终止时一定有 r = l** ，这是「模版二」的标志，也加上了 ***\*「相等终止」\**** 的描述。「错位终止」、「相等终止」是我为了方便行文起的名字，实际上用 **「左闭右闭」** 来指代「模版一」， **「左闭右开」** 来指代「模版二」是目前通用的说法，说的是初始时 l 与 r 的取值范围。不过我对「左闭右闭」、「左闭右开」的称呼不太满意，二者的搜索空间其实是一致的，我尝试去理解这个名称的时候，结合网上的一些说法，我想大概是因为「左闭右闭」的取值范围为 [l, r]（其中 r = n - 1, n = nums.length），写起来像表示实数范围的左闭右闭区间（虽然这个区间取值是离散的整数）。而「左闭右开」表示为 [l, n)，表示 初始 r = n，但 c 取不到 n 值。我觉得很没有道理，因为前者的 c 同样取不到 n，而且二者形式上也不统一，你总不能把后者写成 [l, r)，那就更不对了，总之这是个令我感到困惑的称呼。我提出的命名主要是想强调while终止时 l 与 r 的位置关系，使用不同模版解决各类二分问题时，我们应当时刻记住 l 与 r 的最终位置关系，「错位」和「相等」这两个词能很好的表达相应的位置关系。

<br />

【关于「二段性」】

因为正文内容基于输入数组具有「有序性」的704题介绍，因此对于二分查找更本质的「二段性」概念不会出现在正文中。正式的介绍要延后至「实战应用」中，基于具体题目讲解。因此在这里先提一下 **「二段性」** ，在「实战应用」一节的题解中，你会看到有些题目的数组并不具备有序性，但丝毫不妨碍以二分查找处理。这是因为，只要数组能够根据特定的条件（其实就是「循环不变」）被分为两半，且搜索空间为其中的一半，循环地如此二分下去，直到穷尽原搜索空间，**最终必能确定答案**（存在与否，及若存在是哪个）。这就是「二段性」，更严谨点说是 **「输入序列对于答案具有二段性」**。最典型的莫过于[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) ，输入元素大小和顺序是任意的，只需至少存在一个数，其左右两边的数小于它即可。看起来十分反直觉，但其本质仍然是「循环不变」，了解到这一点后就不会觉得有多特别了。另外，关于「二段性」的名字，不知是何人何时开始称呼的，个人感觉值得推敲，「段」字是名词，属于静态描述，而且隐隐约约让人觉得「段」内元素有某些相同的性质，因为它们属于同一段。个人倾向于「可二分性」或略称「二分性」，「分」是动词，属于动态描述，（也许）更能准确地指出「输入序列对于答案可二分至穷尽」这一本质。这当然只是一点愚见，后续我们还是用行之有年的「二段性」指称之。

<br />

#### 四种一般情形

「相等返回」的写法很好理解，现在来看更一般的情形。所谓「一般」是指要求返回 大于等于 / 大于 / 小于等于 / 小于 target的数字下标。其一般性在于这种不等于的要求涵盖了前述等于的情形。这里将与target相等的元素的下标称作「等于下标」，大于target的元素中最小的那个的下标称作「刚好大于下标」，同理有「刚好小于小标」，不存在所要求的元素时返回-1。具体如下：

1. 情形1: 大于等于。有相等元素时返回等于下标，否则返回刚好大于下标，否则返回 -1。（704题要求为等于下标或-1）
2. 情形2: 大于。不考虑相等，返回刚好大于下标，否则返回-1。
3. 情形3: 小于等于。有相等元素时返回等于下标，否则返回刚好小于下标，否则返回 -1。（704题要求为等于下标或-1）
4. 情形4: 小于。不考虑相等，返回刚好小于下标，否则返回-1。

无论是哪种情形，我们都可以根据「循环不变」原则给出相应的更「一般」的模版一代码。后续我会简单展示 Java / C++ / Python 的二分查找相关源码。其中C++中的lower_bound和Python的bisect_left就对应这里的「情形1」，upper_bound(C++) 和 bisect_right (Python)对应「情形2」，只是对返回规则的定义与此处有所不同。另外，Java中的binarySearch采用的是「相等返回」情形，关于这些我将在「各语言内置二分查找方法(函数)」中说明。现在先讲解如下「情形1」的代码。

```java
// 模版一「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        // return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等
        return l == nums.length ? -1 : l; // 处理: 相等/刚好大于/不存在
    }
}
```

在理解了「循环不变」原理后，编写这个版本的代码时尝试寻找 l 或 r 更新后是否能有类似target必在或必不在某个确定的范围的「循环不变」关系。因为情形1要求「大于等于」，考虑其「补关系」，即若target小于nums[c]，那么 l 更新后就有如下「循环不变」关系1。与「相等返回」不同的，因为没有判等分支， 进入#2 行的条件是 nums[c] >= target，得到如下「循环不变」关系2。

1. 对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。
2. 对于#2行，若进入该分支，则 r 下标更新后其右侧元素「必」大于等于target。

同样地，while终止时有 r = l - 1，根据本情形的「循环不变」关系，此时target必不在 l 左侧，而 r 的右侧必大于等于target，又因为nums是单调递增的，因此断言: l 要么是等于target的数的下标，要么是大于target中最小的那个数的下标。稍等，循环不变只保证了左右侧元素与target的大小关系，并不保证 l 或 r 最终一定在nums的下标范围内。实际上有可能超出一位，即为 r = -1 (nums中所有数都大于target) 或 r = nums.length (nums中所有数都小于target)。因此前述断言还有一个前提，即 l != nums.length，这个条件经由如下对target的三种情况的思考后写就。

- nums中所有元素都小于target时，r 不更新，最终 l = nums.length，因此当这个关系成立时，返回 -1。

- nums中存在元素大于等于target时，由两条「循环不变」关系（或者下图）可知应返回 l 。

- nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回下标0，而刚好有l = 0，因此返回 l 。

于是一个判断即可对应三种情况(后两种都返回 l)。另外，因为 r = l - 1，用 l 或 r来返回都是可以的。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23ke5c4f0j212805074v.jpg" alt="image-20220510200733409" width="500;" />
</div>

下面给出余下情形的代码，分析过程是类似的，不再赘述。其中「情形2(大于)」和「情形4(小于)」不考虑「等于」关系，不能用于处理704题，而「情形1(大于等于)」和「情形3(小于等于)」涵盖了「等于」，可以用来处理704题，只需要在返回值语句上稍作修改即可，细节请见代码。

「情形2」考虑target的三种情况：

- nums中所有元素都小于target时，r 不更新，最终 l = nums.length，因此当这个关系成立时，返回 -1。

- nums中存在元素大于target时，由两条「循环不变」关系可知应返回 l (r 的右侧)。

- nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回下标0，而刚好有l = 0，因此返回 l 。

```java
// 模版一「一般」情形2: 大于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧元素「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        return l == nums.length ? -1 : l; // 处理: 刚好大于/不存在
    }
}
```

「情形3」考虑target的三种情况：

- nums中所有元素都小于target时，应当返回最大下标 nums.length - 1，r未更新，仍有 r = nums.length - 1，因此返回 r。

- nums中存在元素小于等于target时，由两条「循环不变」关系可知应返回 r (l 的左侧)。

- nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回-1，而此时刚好有r = -1，因此返回 r。

意外地发现三种情况都返回 r。但若用此情形处理704题，则需调整，请参考注释行。

```java
// 模版一「一般」情形3: 小于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        // return (r == -1 || nums[r] != target) ? -1 : r; // 704题的返回，处理:相等/不等
        return r; // 处理: 相等/刚好小于/不存在
    }
}
```

先看按「情形1」写出的版本。在理解了「循环不变」原理后，编写这个版本的代码时尝试寻找 l 或 r 更新后是否能有类似target必在或必不在某个确定的范围的「循环不变」关系。因为情形1要求「大于等于」，考虑其「补关系」，即若target小于nums[c]，那么 l 更新后就有如下关系1。与前次分析稍有不同的是 #2 行，我们可以得到如下关系2。经此分析，情形1的代码不难写出。

「情形4」考虑target的三种情况：

- nums中所有元素都小于target时，应当返回最大下标 nums.length - 1，r未更新，仍有 r = nums.length - 1，因此返回 r。

- nums中存在元素小于target时，由两条「循环不变」关系可知应返回 r (l 的左侧)。

- nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回-1，而刚好有r = -1，因此返回 r。

三种情况也都返回 r，整个代码与「情形3」只有一个 '=' 字符的差别。

```java
// 模版一「一般」情形4: 小于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        return r; // 处理: 相等/刚好小于/不存在
    }
}
```



现在来展示一种我认为不太好的「逆习惯」写法（如下，以情形1为例），该写法把 r 的更新写在 l 之前，这仅仅是把if-else处理调换了位置而已，不影响程序正确性。展示这种写法是想建议大家在书写二分查找代码时保持同一种风格和习惯，这样能够减少思考负担。

```java
// 模版一「一般」情形1: 大于等于 (「逆习惯」写法)
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] >= target) r = c - 1; // #1 更新后r右侧「必」大于等于target
            else l = c + 1; // #2 更新后l左侧元素「必」小于target
        }
        // return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等
        return l == nums.length ? -1 : l; // 处理: 相等/刚好大于/不存在
    }
}
```



#### 模版一总结

- 核心在于「错位终止」，即循环终止时有 r = l - 1。而最终的「错位」是通过每次 l 和 r 的更新为 l = c + 1, r = c - 1来实现的。换句话说，「模版一」的标志是while中的 l <= r 以及 l 与 r 更新时的 l = c + 1, r = c - 1，二者相辅相成，共同作用实现了「错位终止」。另外 l 与 r 的初始取值的「左闭右闭」特点也是「模版一」的一个标志。
- 通过 l 左侧和 r 右侧的「循环不变」关系，确定while终止后的目标下标。在「一般」情形中，要考虑不更新导致的越界及其对应的返回前判断。
- 相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，一般版本则一定会穷尽二分过程。

<br />

### 模版二 (相等终止/左闭右开)

#### 相等返回情形

与「模版一」相映，「模版二」的特点在于「相等终止」，即while终止时，l = r。l 与 r 在while循环终止时的关系由它们的更新语句 l = c + 1和 r = c 所决定，如同模版一的分析那样，请参考后续「相等终止图示」。在探究这个模版代码的「循环不变」之前，先行强调，如果 l 与 r 的初始值设置为与「模版一」相同，即 l = 0, r = nums.length - 1，那么由于while的条件是l < r，当nums只有一个元素时，将无法进入while，因此为了能够至少进入一次while，模版二中 r 的初始值为 r = nums.length。而更主要的原因是当target大于nums中所有元素时，r = nums.length 将是这一情况的一个标志，倘若 r 初始值为 nums.length - 1，只看 r 的最终取值是无法判断为上述情况的，仍需要比较一次target与nums中的最后一个元素。在后续「情形3」和「情形4」的代码中还可以进一步体会将 r 初始值设置为 r = nums.length 带来的统一返回值的好处。总之，r = nums.length 是又一个模版二的标志，通常被称作「左闭右开」，而模版一的 l 和 r 的初始取值被称作「左闭右闭」。

```java
// 模版二「相等返回」写法
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c; // 找到目标值直接返回
            else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // nums[c] > target #2 更新后r及其右侧「必」大于target
        }
        return -1;
    }
}
```

此实现的「循环不变」关系为：

1. 对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。
2. 对于#2行，若进入该分支，则 r 下标更新后其及其右侧元素「必」大于target。

同样地，程序执行过程中有两种情况：

1. 情况一：nums[c] == target，直接返回正确的结果。

2. 情况二：while因 l 与 r 不满足 l < r 而终止，此时 l = r （见后续「相等终止图示」）。由「循环不变」关系，对于更新后任意时刻的 l ，其左侧元素必小于target，对于更新后任意时刻的 r，r 及其右侧的元素必定大于target。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h26r2e65j6j20y804gq3d.jpg" alt="image-20220513141509480" width="430;" />
</div>



while终止时，l = r。与「模版一」的「相等返回」分析类似，情况二while终止时 r 及其右侧和 l 的左侧正好覆盖了所有nums的元素，此时可以断言：target必不在nums中。若target大于nums中所有元素，虽然 r 不更新，但最终 l 的左侧覆盖了所有元素(l = r = nums.length)。同样地，target小于nums中所有元素时，l 虽不更新，但最终 r 及其右侧覆盖了所有元素，断言都能够成立。



【相等终止图示】

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h225grbk1xj211g0m6gnn.jpg" alt="image-20220509144531195" width="500;" />
</div>

<br />

#### 四种一般情形

四种一般情形与模版一时所述相同。为引入「无限循环问题」，先给出「情形1」和「情形3」的代码，均依据「循环不变」原则写出，要注意现在的「情形3」代码是错误的。



「情形1」考虑target的三种情况：

- nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 -1。
- nums中存在元素大于等于target时，由两条「循环不变」关系可知应返回 r。
- nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回下标0，而此时 r 正好等于0。

一条判断对应三种情况(两个分支)。若用于处理704题，返回时的判断需做调整，见注释行。

```java
// 模版二「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及r右侧「必」大于等于target
        }
        // return (r != nums.length && nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等
        return r != nums.length ? r : -1; // 处理:等于/刚好大于/不存在
    }
}
```

此处「情形3」为错误代码，不过多分析，专注于后续的「无限循环」。

```java
// 模版二「一般」情形3：小于等于（注意！！！此版本有可能发生无限循环）
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c; // #1 更新后l及l左侧元素「必」小于等于target 
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        // return (r != -1 && nums[l] == target) ? l : -1; // 704题的返回，处理:相等/不等
        return r != -1 ? l : -1; // 处理:等于/刚好大于/不存在
    }
}
```

在实际运行上述代码后，「情形1」准确无误地返回所有结果，但「情形3」却意外地陷入了无限循环。在分析此无限循环现象之前，先提一下这个错误版本的返回语句。可以看到返回语句中竟然用到了 r 和 l，之前的分析不是已经指出while循环结束后 r = l 了吗？有必要再推导一次此版本代码的终止情形，如下。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23da1gb1ej20vi0jo40f.jpg" alt="image-20220510160123800" width="500;" />
</div>

可以看到，终止情形有两种，第二种将有可能导致 r 越界，即当target小于nums中任何一个数时， l 不发生更新 (l == 0)，最终 r = l - 1终止。正因为存在这样的终止情形，所以返回语句中 r 和 l 才会同时存在。总之虽然从两种终止情形中我们感觉到了一些坏味道，但这版代码看起来没什么问题。但我们已经知道了它可能会陷入无限循环，下面开始分析。

<br />

#### 发生无限循环的条件及证明

在分析前多说几句，这部分内容在之后给出相应不发生无限循环的正确版本后，多少有些多余，也许还增加了阅读负担甚至可能会扰乱读者对模版的记忆。不过我想说的是，这篇总结的写作动机正是因为我遇到了这个无限循环的问题，当然这是因为当时对二分查找理解还不够透彻（现在也不敢说完全理解，但比之前好点）而写出的错误代码，哪怕它也是基于「循环不变」原理写出的。总之我希望把这个过程记录下来，也许有人也遇到过相同的情况而困惑不已，帮人解惑亦未可知。



首先「循环不变」关系在整个程序运行过程中是由「因果律」所保证的，问题肯定不会出现在「循环不变」上。接着我们再来审视模版二的代码，并尝试从它与模版一的不同处着手。不难看到除了while条件的不同，最大的不同在于 l 和 r 的更新语句。模版一中 l 和 r 的更新都是在 c 的基础上错一位，但模版二中却有可能保持与 c 相等。循环中的变量只有l、r、 c，对于「情形1」，如果某一次循环进入else分支，使得 r = c，且进入本次循环时 r 原本就等于 c，那么 l 与 r 都将保持不变，c 由 l 与 r 得到，那么 c 也会继续保持不变，也就有可能发生无限循环。对于「情形3」也是如此，也有可能因为进入 l = c 分支而发生无限循环。我们已经知道「情形1」代码没问题，但「情形3」代码发生无限循环，现在逐个分析。为方便分析，将「情形1」和「情形3」的代码并列如下，左侧为「情形1」，右侧为「情形3」。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23d960g4pj21b009gdhi.jpg" alt="image-20220510160034115" width="750;" />
</div>

##### 情形1的分析

发生循环只可能是如下场景：某一次进入while时， c = l + (r - l) / 2，使得 nums[c] >= target，进入else分支，r = c，且假设此次循环开始时就有 r = c，于是 l 与 r 在此次循环中不变，下一次循环首先计算的 c 也不变，循环产生。但实际运行结果告诉我们，程序没有问题，因此有必要检视上述假设的正确性。我们首先假设了 r = c，可以将计算 c 时的 c 换成 r，有 r = l + (r - l) / 2，我们知道这个式子与 r = (l + r) / 2相等，只是为了防止溢出才写成前一种形式。为方便分析换回后一种简单形式。l + r 要么为偶数，要么为奇数：

- l + r 为偶数时，能够被2整除，有 2r = l + r，即 r = l。但while条件已经限制了 l < r，l = r 时不可能进入while循环，故 r = c 的假设与 l + r 为偶数互相矛盾。
- l + r 为奇数时，我们转换成 r = (l + r - 1) / 2，该式结果与奇数情形向下取整的结果相同，得到 r = l - 1，这显然也是不可能发生的，故r = c 的假设与 l + r 为奇数互相矛盾。

由此我们得出结论，左侧「情形1」的代码虽然看起来有可能产生循环，但发生循环的条件根本不可能达到，因此程序一定能够终止运行，又依据前述「循环不变」的原理，代码的正确性得以保证。

##### 情形3的分析

分析过程一致。产生循环的条件是某一次进入while时，c = l + (r - l) / 2，使得 nums[c] <= target，于是进入 if 分支，l = c，且假设此次循环开始时 l = c。检视该假设的正确性，将计算 c 的式子中的 c 换成 l，有 l = (l + r) / 2。

- l + r 为偶数时，l = r，与进入while的条件矛盾，故 l = c 的假设与 l + r 为偶数互相矛盾。
- l + r 为奇数时，l = r - 1。意想不到的事情发生了，这是可能达到的一种情况。也就是说，「情形3」代码在某一次进入while时，若 l = r -1，且nums[c] <= target时，将发生无限循环。

举个例子，对于数组 nums = {-1,0,3,5,9,12}，target = 3，以其为输入运行「情形3」代码，程序将在 l = 1, r = 2 （满足 l = r - 1，且此时nums[c] = nums[1] = 0 <= target = 3）时开始无限循环。但若target = 5，则程序正常结束，返回正确的结果（建议实际动手分析一下）。实际上只要target大于nums中所有数字，则必然发生无限循环，因为 r 不会更新， l 向 r 逐渐靠近后最终一定位于 r 的前一位，即 l = r - 1，而此时必然有 nums[c] <= target，于是会在这个时候陷入无限循环。

<br />

#### 破除无限循环及正确写法

上述分析指出，导致陷入无限循环的关键在于 l = c 语句，从该语句推导出无限循环发生的条件是有可能出现的。因此对于「情形3」，我们需要稍加改造。改造点自然在 l = c 语句上。我们仍旧让这条更新语句为 l = c + 1，那么条件也要相应地改成 nums[c] < target，目的是要让这个「循环不变」关系成立：l 更新后其左侧元素「必」小于target。然后 r 的更新语句要调整回 r = c。两条「循环不变」关系与「情形1」一样：

1. 对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。
2. 对于#2行，若进入该分支，则 r 下标更新后 r 及其其右侧元素「必」大于等于target。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23mbkfjkfj20wm04wgm2.jpg" alt="image-20220510211416520" width="500;" />
</div>

这时候我们会发现，不是又变回情形一了吗？没错，直到while结束前的语句，与情形一是完全一致的（因此终止情形也只有 l = r 一种）。当while结束后，l 左侧元素必小于target，r 及其右侧元素必大于等于target。我们只需在返回前调整一下判断，就能返回正确结果了。判断语句经由如下思考后写就。

- nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。
- nums中存在元素小于等于target时，由两条「循环不变」关系可知，如果nums[r]等于target，需要返回 r，否则返回 r - 1。
- nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1正好等于 -1，应当返回 r - 1。

可以看到，返回值仍旧是两种情形（r 或 r-1）。由此我们写出「模版二」的正确的「情形3」代码。

```java
// 模版二「一般」写法之情形3（正确版1）
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及其右侧「必」大于等于target
        }
        // return (r != nums.length && nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等
        return (r == nums.length || nums[r] != target) ? r - 1 : r; // 处理:相等/刚好小于/不存在
    }
}
```

关于 if-else 的条件和 l 与 r的更新，有必要再多说几句（其实行文中已经重复强调过多次）。 if-else 的条件和 l, r 更新语句是要根据返回需求来配合的，写法很灵活，也正是因为这样才容易写错。为了体现这一点，我再给出「情形3」的另一种正确版本。如下，到while结束之前，与上一个版本的写法只有 if 条件中一个 '=' 字符的差别。该差别使得两个「循环不变」关系为如下：

1. 对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于等于target。
2. 对于#2行，若进入该分支，则 r 下标更新后 r 及其其右侧元素「必」大于target。

仍旧考虑target的三种情况：

- nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。
- nums中存在元素小于等于target时，由两条「循环不变」关系可知应返回 r - 1。
- nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1正好等于 -1。

三者返回都是相同的 r - 1，由此我们得到如下「情形3」的正确版2。如果用来解决704题，见注释行。值得一提的是，若直接返回 r - 1，虽是正确的，但形式上却不容易看出 r = 0 时返回 -1 对应nums中所有元素都大于target这一情况，因此我们选择写成 `return r > 0 ? r - 1 : -1;` 这样的形式 (来自 @masterx89 的建议)。

```java
// 模版二「一般」写法之情形3(正确版2)
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l及其左侧元素「必」小于等于target 
            else r = c; // #2 更新后r右侧「必」大于target
        }
        // 原先针对 704 的返回有漏洞，该修改（下面一行）来自 Hankai Xia @masterx89 同学，感谢
        // return (r > 0 && nums[r - 1] == target) ? r - 1 : -1; // 704题的返回，处理:相等/不等
        // return r - 1; // 通过分析target的三种情形得到的统一返回值
        return r > 0 ? r - 1 : -1; // 但写成此种形式，逻辑更佳 （来自Hankai Xia @masterx89 的建议）
    }
}
```



现在，给出模版二「情形2」和「情形4」的代码如下。同样地，这两种情形不涵盖等于，因此不用于704题。省略详细分析过程，给出target的三种情况时对应的返回，由前面的经验，我们能够立即看出代码的正确性。

「情形2」考虑target的三种情况：

- nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 -1。
- nums中存在元素大于target时，由两条「循环不变」关系可知应返回 r。
- nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回下标0，而此时 r 正好等于0。

```java
// 模版二「一般」情形2: 大于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧「必」小于等于target 
            else r = c; // #2 更新后r及r右侧「必」大于target
        }
        return r == nums.length ? -1 : r; // 处理:刚好大于/不存在
    }
}
```

「情形4」考虑target的三种情况：

- nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。
- nums中存在元素小于target时，由两条「循环不变」关系可知应返回 l - 1 (即 r - 1)。
- nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1 正好等于-1。

```java
// 模版二「一般」情形4: 小于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及其右侧「必」大于等于target
        }
        return r - 1; // 处理:刚好小于/不存在
    }
}
```



#### 模版二总结

- 核心在于「相等终止」，即循环终止时有 l = r。而最终的「相等」是通过每次 l 和 r 的更新为 l = c + 1, r = c 来实现的。换句话说，「模版二」的标志是while中的 l < r 以及 l 与 r 更新时的 l = c + 1, r = c，二者相辅相成，共同作用实现了「相等终止」。另外 l 与 r 的初始取值的「左闭右开」特点也是「模版二」的一个标志。

- 通过 l 左侧和 r 右侧的「循环不变」关系，确定while终止后的目标下标。

- 相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，而一般版本则一定会穷尽二分过程。

- 必须避免 l = c 更新分支的出现，否则在一定条件下会发生无限循环。

<br />

### 各语言内置二分查找方法(函数)

简单介绍Java / C++ / Python中的二分查找相关方法。就模版而言，Java和C++的二分方法(函数)采用了「模版一」，Python采用了「模版二」，就各自实现而言，在返回值上有不同定义。

#### Java

JDK中内置的二分方法为binarySearch。内部调用了如下方法，可以看到使用的是「模版一」的「相等返回」写法。只在return上与我们给出的版本有差异。这个返回的意思是：

- 若找到等于key的元素，返回改元素下标（若有多个相等元素，返回其中之一的下标，不保证是哪一个）。
- 若找不到，则想象将key作为第n个元素插入(从第1个开始算起)，返回 -n。

```java
private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                 int key) {
    int low = fromIndex;
    int high = toIndex - 1;

    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}
```

#### C++

STL中的二分查找方法为 [lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound) / [upper_bound](https://en.cppreference.com/w/cpp/algorithm/upper_bound) / [binary_search](https://en.cppreference.com/w/cpp/algorithm/binary_search)。



如下[lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound) 返回「大于等于」val的元素下标，采用的是「模版一」的「情形1」，与我们给出的版本的区别在return语句上，该方法不做判断，也就是说当val大于所有元素时，返回最后一个元素下标+1（即等同于我们的nums.length）。

※ [distance](https://www.cplusplus.com/reference/iterator/distance/)方法返回从first(包括)到last(包括)元素总数，所以count > 0 其实就等同于 l <= r。

```c++
template <class ForwardIterator, class T>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; advance (it,step);
    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)
      first=++it;
      count-=step+1;
    }
    else count=step;
  }
  return first;
}
```

[upper_bound](https://en.cppreference.com/w/cpp/algorithm/upper_bound)返回「大于」val的元素下标，采用的是「模版一」的「情形2」，与我们给出的版本的区别在return语句上，该方法不做判断，也就是说当val大于所有元素时，返回最后一个元素下标+1（即类似nums.length）。

```c++
template <class ForwardIterator, class T>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = std::distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; std::advance (it,step);
    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)
      { first=++it; count-=step+1;  }
    else count=step;
  }
  return first;
}
```

[binary_search](https://en.cppreference.com/w/cpp/algorithm/binary_search)调用lower_bound，若找到返回true，不存在返回false。

```c++
template<class ForwardIt, class T>
bool binary_search(ForwardIt first, ForwardIt last, const T& value)
{
    first = std::lower_bound(first, last, value);
    return (!(first == last) && !(value < *first));
}
```

#### python

python中的二分方法为 [bisect_left](https://github.com/python/cpython/blob/3.10/Lib/bisect.py) / [bisect_right](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)。



如下[bisect_left](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)返回「大于等于」x的元素下标，若都小于x，返回最后一个元素下标+1（即类似nums.length），与C++中的lower_bound一致，但使用的是「模版二」的情形1写法。

```python
def bisect_left(a, x, lo=0, hi=None, *, key=None):
    """Return the index where to insert item x in list a, assuming a is sorted.
    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will
    insert just before the leftmost x already there.
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    # Note, the comparison uses "<" to match the
    # __lt__() logic in list.sort() and in heapq.
    if key is None:
        while lo < hi:
            mid = (lo + hi) // 2
            if a[mid] < x:
                lo = mid + 1
            else:
                hi = mid
    else:
        while lo < hi:
            mid = (lo + hi) // 2
            if key(a[mid]) < x:
                lo = mid + 1
            else:
                hi = mid
    return lo
```

[bisect_right](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)返回「大于」x 的元素下标，若都小于x，返回最后一个元素下标+1（即类似nums.length），与C++中的upper_bound一致，但使用的是「模版二」的情形2写法。

```python
def bisect_right(a, x, lo=0, hi=None, *, key=None):
    """Return the index where to insert item x in list a, assuming a is sorted.
    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will
    insert just after the rightmost x already there.
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    # Note, the comparison uses "<" to match the
    # __lt__() logic in list.sort() and in heapq.
    if key is None:
        while lo < hi:
            mid = (lo + hi) // 2
            if x < a[mid]:
                hi = mid
            else:
                lo = mid + 1
    else:
        while lo < hi:
            mid = (lo + hi) // 2
            if x < key(a[mid]):
                hi = mid
            else:
                lo = mid + 1
    return lo
```



### 总结

- 本文详细介绍了二分查找中常用的两种模版，并以[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)为例展示了两种模版的「相等返回」情形和「一般」情形的写法。
- 细致地分析了各种实现中的「循环不变」关系，并指出如何通过这些不变的关系得到正确的答案。
- 着重强调了两种模版中与「循环不变」相关联的while条件及其对应的 l 与 r 的更新语句，并用图示简单展示了while终止时 l 与 r 的确定的等式关系。
- 在模版二中，从 l 与 r 更新语句出发（r = c, l = c），提出即便是遵循「循环不变」的实现，仍会发生无限循环的情形，并证明了该情形的发生条件。这一点指导我们在「模版二」的各类实现中，要避免 l = c 更新分支的出现。经过思考，我们给出了避免无限循环的正确版本。
- 同一个模版的同一种情形，有时存在多种写法。
- 简单展示了Java, C++, Python中相关二分查找方法(函数)分别对应本文介绍的哪种模版的那种情形。

<br />

### 实战应用

本节逐个分析如下二分题目。

| 区分     | 题目                                                         | 备注 |
| -------- | ------------------------------------------------------------ | ---- |
| 模版题   | [704. 二分查找](https://leetcode.cn/problems/binary-search/) (简单) |      |
|          | [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/) (简单) |      |
|          | [374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)(简单) |      |
|          | [278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/) (简单) |      |
|          | [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) (中等) |      |
|          | [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) (中等) |      |
|          | [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/) (简单) |      |
|          | [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) (中等) |      |
| 二段性   | [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) (中等) |      |
|          | [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) (中等) |      |
|          | [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) (困难) |      |
|          | [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) (中等) |      |
| 抽象二分 | [658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/) (中等) |      |
|          | [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) (中等) |      |
|          | [LCP 12. 小张刷题计划](https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/) （中等） | todo |
|          | [1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)（中等） | todo |
|          | [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)（中等） | todo |
|          | [1552. 两球之间的磁力](https://leetcode.cn/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/两球之间的磁力)（中等） | todo |
|          | [774. 最小化去加油站的最大距离](https://leetcode.cn/problems/minimize-max-distance-to-gas-station/) (困难) | todo |
| 二分思想 | [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/) (中等) |      |
|          | [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/) (困难) | todo |
| 未分类   | [270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/) (简单) |      |
|          | [702. 搜索长度未知的有序数组](https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/) (中等) |      |
|          | [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/) (中等) |      |
|          | [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/) (简单) |      |
|          | [744. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/) (简单) |      |
|          | [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/) (简单) |      |
|          | [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/) (简单) |      |
|          | [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) (中等) |      |
|          | [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) (中等) |      |
|          | [719. 找出第 k 小的距离对](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/) (困难) |      |
|          | [410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/) (困难) |      |
|          | [852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/) (简单) |      |
|          | [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/) (中等) |      |
|          | [528. 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/) (中等) |      |
|          |                                                              |      |



#### 704. 二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/) (简单)。最基本「存在性」二分查找问题，即只考察是否存在目标值，而不考虑大于小于等情形。前文已介绍过，使用两个模版中的「相等情形」、「情形1」和「情形3」的任意一份代码，均可解决，此处不再列出。

<br />

#### 69. x的平方根

[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)(简单)。按题意，立即看出是「小于等于」情形，即在 [0, x] 范围内的整数中找到一个数 k ，使得 k * k <= x。使用两个模版中的「情形3」即可。在充分理解前面讲解的内容之后，我们仅需记忆两个模版的三个特征即可（这三个特征是三位一体的模版标志），对于模版一，如下：

1.  r 的初始值为搜索空间上界，在本题中为 r = x。
2. while中为 <= 。
3. l 与 r 的更新形式，即 l = c + 1, r = c - 1。

对于模版二，如下：

1.  r 的初始值为搜索空间上界 + 1，在本题中为 r = x + 1。
2. while中为 < 。
3. l 与 r 的更新形式，即 l = c + 1, r = c。

对本题来说，从简便性来看，两个模版没有区别，剩下要做的只有 if 中的条件需要略加思考，因为是「小于等于」情形，那么 if 中的判断能够将 l 或 r 的左侧都断言为「小于等于」即可，立刻写出 if(c * c <= x) l = c + 1，这样就可以使得 l 左侧满足 c * c <= x，若用模版一，返回 l - 1 (或 r)，若用模版二，返回 l - 1 (或r - 1)。需要注意的是， c * c 可能溢出，需转型为long。

```java
// 模版一「一般」情形3: 小于等于
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x;
        while(l <= r){
            int c = l + (r - l) / 2;
            if((long) c * c <= x) l = c + 1; // #1 更新后l左侧「必」小于等于x
            else r = c - 1; // #2 更新后r右侧「必」大于x
        }
        return r; 
    }
}
```

使用模版二时，还需注意，因为 r = x + 1，若x = 2^31 - 1，则 r 刚好溢出，因此对于这个情形需要特别处理，见如下。从这一点来看，本题用模版一更好。

```java
// 模版二「一般」情形3: 小于等于
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x == Integer.MAX_VALUE ? x : x + 1; // r的取值需要稍微注意
        while(l < r){
            int c = l + (r - l) / 2;
            if((long) c * c <= x) l = c + 1; // #1 更新后l及其左侧元素「必」小于等于x
            else r = c; // #2 更新后r右侧「必」大于x
        }
        return r - 1; 
    }
}
```

<br />

#### 374. 猜数字大小

[374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)(简单)。仍旧是最基本的「存在性」题型。采用两个模版的「相等返回」、「情形1」或「情形3」均可。这里只列出模版一的「相等返回」和模版二的「情形1」供参考，其他的都非常容易写出。需要强调的是，虽有多种不同写法，但对「是否存在」的基本题型，选用「相等返回」写法为佳，其次，因为「模版二」r 的初始值需考虑溢出特例，从这一点上看，选用「模版一」为佳（除非数据范围不会导致 r 初始时溢出）。

```java
// 模版一「相等返回」
public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(guess(c) == 0) return c;
            else if(guess(c) == 1) l = c + 1;
            else r = c - 1;
        }
        return -1; // 因为 c 必存在，这条语句不会执行
    }
}
```

使用模版二时，本题无需令  r = n + 1，只有一个元素时正好返回正确答案，被选数字为最大的那个数时，也正好返回最大数。

```java
// 模版二「情形1」：大于等于
public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(guess(c) == 1) l = c + 1;
            else r = c;
        }
        return r; // 因为 c 必存在，无需判断
    }
}
```

<br />

#### 33. 搜索旋转排序数组

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) (中等)。这一题相比典型的有序数组二分，输入数组并不整体有序，而是分为两个有序的部分。你可能在其他地方有看到过这么一种说法，即二分查找的前提只需要输入数组具有「二段性」而不要求整体的「有序性」，所谓「二段性」即每一次循环查找，均可排除掉一半的答案（或者说将搜索空间缩小一半），其实也就是 l 或者 r 的更新。这一题就很好地体现了这一说法。根据题目要求，这也是一个基本的「存在性」的问题，因此我们采用「相等返回」写法。if(nums[c] == target) return c 的判断分支自不必说，重点来说两个不等分支的写法。如果是有序数组，对于nums[c]，只需要与target对比即可知道应该往哪个方向收缩搜索空间（更新 l 或 r），但本题不行，比如nums[c] < target，则targe的下标t即有可能在 c 之前，也有可能在 c 之后。实际上我们仅需先行判断 c 属于哪个部分，就可以通过「循环不变」的断言来更新 l 或 r ，从而「一半一半」地压缩搜索空间了。



我们通过下图来理解，c 落入哪个空间可以通过用nums[c]与整个数组的首尾元素比较得出。nums[0]是第一段递增序列的起始元素，nums[n - 1]是第二段递增序列的末尾元素(n 为nums长度)。当 c 落入第一段中(nums[c] >= nums[0])，按照习惯，我们先更新 l，即寻找使得target「必」在 c 右侧的条件（这就是我们主动寻找的「循环不变」），不难写出该条件为 target > nums[c] || target < nums[0]，注意若只写第一个条件，会漏掉target在第四象限的情况，于是更新 l = c + 1。否则「必」在左侧，更新 r = c - 1。类似地，如果落入第二个递增区间 (nums[c] <= nums[n - 1])，仍旧先更新 l，使得target「必」在c 右侧的条件为 nums[c] <  target <= nums[n - 1] (这也是我们主动寻找的「循环不变」)，于是更新 l = c + 1，否则更新 r = c - 1。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h25qbfp8tkj21410u0abm.jpg" alt="image-20220512170335955" width="700;" />
</div>

先行判断 c 落于哪个区间会产生两个大的if-else分支，每个分支中依据「循环不变」来更新 l 和 r 与常规题目相同，很容易写出如下「模版一」的「相等返回」情形代码。处理更多的题目之后，你可能会发现「循环不变」的指导变得越来越自然，你甚至不会特别去提醒自己这个原则，而是自然地使用这个原则。

```java
// 「模版一」相等返回
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target > nums[c] || target < nums[0]) l = c + 1; // 在c右侧
                else r = c - 1; // 在c左侧
            }
            else { // c 落入第二个递增区间
                if(target > nums[c] && target <= nums[n - 1]) l = c + 1; // 在c右侧
                else r = c - 1; // 在c左侧
            }
        }
        return -1;
    }
}
```

前面我们强调总是按习惯先更新 l，如果你的习惯是先更新 r，那么你应该会写成如下形式。先更新哪一个导致条件有所区别，但这不要紧，只要我们遵循「循环不变」，正确更新 l 和 r 即可。

```java
// 「模版一」相等返回，先更新 r
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target >= nums[0] && target < nums[c]) r = c - 1; //在c左侧
                else l = c + 1; // 在c右侧
            }
            else { // c 落入第二个递增区间
                if(target < nums[c] || target > nums[n - 1]) r = c - 1; // 在c左侧
                else l = c + 1; // 在c右侧
            }
        }
        return -1;
    }
}
```

「存在性」问题用情形1（大于等于）或情形3（小于等于）也是可以解决的，这里选用「模版二」的「情形1」来展示不同的解法。不过我必须再次声明，对于「存在性」问题，「相等返回」的写法是首选。这里只不过是想表现出如果全面理解了本文，你可以随机采用一种能够解决问题的「情形」写法，而不再存在该背哪个模版，或该用哪个模版的问题了。

```java
// 「模版二」情形1
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target < nums[0] || target > nums[c]) l = c + 1; // target不在左侧
                else r = c; // target下标为r或在r右侧
            }
            else { // c 落入第二个递增区间
                if(target > nums[c] && target <= nums[n - 1]) l = c + 1; // target不在左侧
                else r = c; // target下标为r或在r右侧
            }
        }
        return (r != n && nums[r] == target) ? r : -1;
    }
}
```

<br />

#### 153. 寻找旋转排序数组中的最小值

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) (中等)。本题是[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)的变形，与之不同的是，这里没有了显式的target，不过这完全不要紧（反而更简单），只要我们找到更新 l 和 r 的条件即可，回想我们在题33中画的图，要找的数字是第二个递增区间的第一个元素的下标，因此只需要判断 c 在哪一个区间，通过该信息来更新 l 和 r 来逼近目标下标。若在第一个区间，则应当更新 l，排除左侧的可能性，若在第二个区间，则应当更新 r，排除右侧的可能性。本题显然不属于「存在性」类型，所以应当采用「相等返回」之外的写法。下面给出「模版一」的写法。需要注意的是，从第一个if更新语句可以看到，我们是以一定存在两个区间为前提来处理的，因此当nums「旋转」回初始状态或只有一个数字时，要以一条特判处理之。

```java
// 模版一
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        if(nums[0] <= nums[n - 1]) return nums[0]; // 原数组情形或只有一个数字
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]) l = c + 1; // 排除l左侧
            else r = c - 1; 
        }
        return nums[l]; // l = r + 1，返回nums[r + 1]也可以
    }
}
```

你当然也可以用「模版二」解决。

```java
// 模版二
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n;
        if(nums[0] <= nums[n - 1]) return nums[0]; // 原数组情形或只有一个数字
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]) l = c + 1; // 排除l左侧
            else r = c;
        }
        return nums[l]; // l = r，返回nums[r]也可以
    }
}
```

<br />

#### 154. 寻找旋转排序数组中的最小值 II

[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) (困难)。本题是[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) 的变形，与153题的不同处在与元素大小可以相等。因此我们无法通过nums[c] 与 nums[0] 或与 nums[n - 1]的比较来确定得更新 l 和 r，这一点很容易通过下图看出来，当c位于如下两侧的时候nums[c]相等，如果是左边的情形，应该更新 l，如果是右边的情形，应该更新 r，但现在无法确定了。总之这个特点使得我们没法简单套用模版，但不要紧，只要找到「循环不变」关系即可。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h260nzzhrxj20nu0budg5.jpg" alt="image-20220512230140376" width="300;" />
</div>

先罗列容易看出的事实：

1. nums[0] >= nums[n - 1]，如果nums[0] < nums[n - 1]，说明此数组经过旋转回到了未旋转时的状态，即单调状态。
2. 最小值左右侧元素都必大于等于该元素。

从第2点来看，我们至少有这两个循环不变关系，nums[c] > nums[n - 1]，则 l = c + 1，nums[c] < nums[n - 1], r = c。进入这两个分支，我们能够将搜索空间减小一半。r 的更新写成 r = c 是因为当 c 恰好是最小值下标且 nums[c] < nums[n - 1]时，若 r = c - 1，我们将会跳过最小值，不便于返回，因此写成类似「模版二」的形式，使得查找结束时 r 为最小值下标（l = r，返回nums[l]也一样）。现在还差一种情况，即 nums[c] == nums[n - 1]，如前所述，此种情形我们无法做到减小一半空间，但必须更新 l 或 r 使得我们总是能够缩小搜索空间来逼近目标，比如可以收缩一位，l++ 或者 r--。尝试寻找这个分支的「循环不变」关系。经过仔细思考，我们发现对于nums[c] == nums[n - 1]，无论是 l++ 还是 r-- 均不可行，问题还是出在元素可以相等上。例如通过前两个分支，此时 c 恰好是最小值下标。而下一次循环有可能通过该分支前进(l++)或后退(r--)一位而错过该正确下标。例如nums = {2,1,2,2}，第一次进入while使得r更新为 r = c = 1，恰好是最小值下标，下一次进入while时 nums[c] = nums[0] = 3 = nums[n - 1] = 3，无论是l++还是r--，都会错过最小值。调整分支的条件的一个方向是，不再与固定的nums[n - 1]比较，而是与nums[r]和nums[l]比较，这么做的道理在于nums[l]始终为第一个单调区间的最小值，nums[r]始终保持为第二个单调区间的最大值，利用这个特点，可以维持「循环不变」，即前两个分支变为：

```java
if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的l左侧
else if(nums[c] < nums[l]) r = c; // 最小值不再更新后的r的右侧
```

我们知道一定有 nums[l] >= nums[r]，所以第三个分支仅剩下nums[c] == nums[l] == nums[r]这一种可能，其循环不变关系需要仔细推敲。因为nums[c] == nums[r]，如果此时 c == r，说明 l == c == r，即这是最后一次更新，nums[l] == nums[r]就是最小值。如果c < r，说明nums[c]是比nums[r]更靠左的可能的最小值，因此可以不用考虑nums[r]，也就是说，这个分支可以用来更新r，即 r--，且不会出现我们前面所分析的错过最小值的情况。至此我们得到了完整的代码。同样地，我们可以加一个特判用以对旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字时做快速地判断返回，实际上不用这个特判也是可以的，因为如果是未旋转状态，那么会一直执行 r--，直到 l = r = 0，此时返回nums[l]恰好是正确的，nums只有一个元素的情况也同理。还需要注意的是，虽然看起来像「模版二」，但 r 的初始值为 r = n - 1，这是因为 if 判断中有nums[r]，r = n 时越界。

```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        if(nums[0] < nums[n - 1] || n == 1) return nums[0]; // 旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字，此行可省略
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的l左侧
            else if(nums[c] < nums[l]) r = c; // 最小值不再更新后的r的右侧
            else r--; 
        }
        return nums[l]; 
    }
}
```

#### 81. 搜索旋转排序数组 II

[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) (中等)。类似于153和154题的关系，本题是33题的进阶，区别在于元素可重复。有了154题的经验，我们可以写出如下代码。首先是判断nums[c]位于哪个区间时，不与固定的首尾元素比较，而是与当前搜索空间的上下界比较，即#1，#2两处。#1分支说明c在区间一中，通过#2，#3判断target在c的哪一侧，#5和#6同理。#1和#4之外的情形，仅剩 nums[c] == nums[0] == nums[n - 1]这一种可能，此时将nums[c]与target做比较，可判断target在哪个区间，这时候由于无法确定nums[c]在哪个区间，因此不能通过c来更新 l 或 r，但可以逐位移动。

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        if(target == nums[0] || target == nums[n - 1]) return true;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return true;
            if(nums[c] > nums[r]){ //  #1 c必在区间一
                if(nums[c] < target || target < nums[0]) l = c + 1; // #2 target在c右侧
                else r = c - 1; // #3 target在c左侧
            }
            else if(nums[c] < nums[l]){ // #4 c必在区间二
                if(nums[c] < target && target < nums[0]) l = c + 1; // #5 target在c右侧
                else r = c - 1; // #6 target在c左侧
            }
            else{ // #7 nums[c] == nums[0] == nums[n - 1]
                if(nums[c] < target) l++; // #8 target必在区间一
                else r--; // #9 nums[c] > target，target必在区间二
            }
        }
        return false;
    }
}
```

#### 278. 第一个错误的版本

[278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/) (简单)。立刻看出是「大于等于」情形，且一定有解，返回时无需判断。!isBadVersion(c) 就相当于 nums[c] < target，仅此而已。

```java
// 模版一大于等于情形
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, r = n;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(!isBadVersion(c)) l = c + 1; // 必不在更新后的l左侧
            else r = c - 1;
        }
        return l;
    }
}
```

```java
// 模版二大于等于情形，r 初始时不需要设置为n + 1，因为不管是n = 1还是错误版本再最后，都正好能正确返回
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(!isBadVersion(c)) l = c + 1; // 必不在更新后的l左侧
            else r = c;
        }
        return l;
    }
}
```

#### 162. 寻找峰值

[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) (中等)。要求山峰值严格大于左右，立刻感觉到这是为「模版二」量身定制的场景。因为模版二循环终止时 l = r，若「循环不变」为 l 左侧一位小于nums[l]，r 右侧一位小于nums[r]，最终 l = r，那么l (即 r) 一定是顶峰。此循环不变关系很容易找到，即 nums[c] 与 nums[c + 1]比较，nums[c] < nums[c + 1]则更新 l = c + 1，即有 l 左侧一位小于nums[l]，另外就是nums[c] > nums[c + 1]时更新 r = c，即有 r 右侧一位小于 nums[r]。题目已声明不存在相邻元素相等的情况，因此这两个条件就足够完备了。如下为「模版二」写法，因为只有一个元素或山峰在最右侧时均可正确返回结果，因此 r 初始不必为 nums.length。另外也容易看出 c + 1 不可能越界。这一题再次向我们展示了能够应用二分查找的问题，其本质是具有「二段性」而非「有序性」。而所谓「二段性」的本质又回归到「循环不变」，在「循环不变」中不断压缩搜索空间，直到压缩出明确的结果，然后以「循环不变」的事实宣告这个结果的性质。

```java
// 模版二
class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < nums[c + 1]) l = c + 1; // c到c+1上升
            else r = c; // c到c+1下降
        }
        return r; // l或r都可以
    }
}
```

虽然这题有强烈的「模版二」特点，但略加思考，因为题目声明了相邻元素不会相等，那么「大于」、「小于」情形也有可能能够解决此题。我们尝试分析「模版一」的「大于」写法。如下，l 更新后 nums[l] > nums[l - 1]是显然的。若 r 更新为 r = c - 1，是因为 nums[c] > nums[c + 1]，其实就是 nums[r + 1] > nums[r + 2]。而循环终止时 l = r + 1，因此nums[l]刚好就是山峰。所以此写法也是可行的，与前一种实现不同的是这里 c + 1可能导致nums[c + 1]越界，仅在l = r = nums.length - 1时发生，此时可直接返回nums.length - 1。

```java
// 模版一「大于」情形
class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(c == nums.length - 1) return c;
            if(nums[c] < nums[c + 1]) l = c + 1; // 更新后 l 比左邻大
            else r = c - 1; // nums[c] > nums[c + 1]，对于更新后的 r, nums[r+1] > nums[r+2]
        }
        return l; 
    }
}
```

#### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) (中等)。根据题意，找第一个位置就是「大于等于」情形，最后一个位置就是「小于等于情形」。用相应的情形写法分别找到即可，下面展示的代码中，用「模版一」的「大于等于」写法寻找元素的第一个位置，用「模版二」的「小于等于」寻找元素的最后一个位置。

```java
// 模版一（找首位） + 模版二（找末位）
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        int[] ans = new int[2];
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c - 1;
        }
        ans[0] = (l < n && nums[l] == target) ? l : - 1;
        l = 0;
        r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1;
            else r = c;
        }
        ans[1] = (l > 0 && nums[l - 1] == target) ? l - 1 : -1;
        return ans;
    }
}
```

你当然也可以用模版一找末位，二用模版二找首位，用法是自由的，代码细节不再赘言。

```java
// 模版二（找首位） + 模版一（找末位）
// 小于等于 && 大于等于
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        int[] ans = new int[2];
        while(l < r){ 
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c;
        }
        ans[0] = (l < n && nums[l] == target) ? l : -1;
        l = 0;
        r = n - 1;
        while(l <= r){ 
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1;
            else r = c - 1;
        }
        ans[1] = (r >= 0 && nums[r] == target) ? r : -1;
        return ans;
    }
}
```

#### 35. 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/) (简单)。标准的「大于等于」情形。

```java
// 模版一
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c - 1;
        }
        return l;
    }
}
```

```java
// 模版二
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c;
        }
        return l;
    }
}
```

#### 74. 搜索二维矩阵

[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) (中等)。只需将坐标从二维映射到一维，即转变为标准的「相等返回」情形。

```java
// 模版一：相等返回
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length, l = 0, r = m * n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            int cur = matrix[c / n][c % n];
            if(cur == target) return true;
            else if(cur < target) l = c + 1;
            else r = c - 1; 
        }
        return false;
    }
}
```

```java
// 模版二：相等返回
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length, l = 0, r = m * n;
        while(l < r){
            int c = l + (r - l) / 2;
            int cur = matrix[c / n][c % n];
            if(cur == target) return true;
            else if(cur < target) l = c + 1;
            else r = c; 
        }
        return false;
    }
}
```

#### 658. 找到 K 个最接近的元素

[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/) (中等)。一个比较容易想到的做法是先找到 x 所在位置idx，然后要求的 k 个数一定位于从 x 往前 k 个数字，往后 k 个数字这个范围之间。由于要求的k个数字是连续的，自然想到滑动窗口。具体做法如下：

1. 由于x可能不存在，因此用「小于等于」或「大于等于」 情形的二分查找找到目标下标idx，这里我们选用「小于等于」。
2. 窗口滑动范围为 [max(0, idx - k + 1), min(n - 1, idx + k)]，该范围内最多 2k - 1个数字，注意max和min的作用是防止前面或后面的数不足。
3. 计算第一个窗口的delta，delta指的是窗口内所有数字与x的差的绝对值之和。记录此时的窗界，作为具有最小delta窗的窗界。
4. 逐位滑动窗口，计算进入窗口和离开窗口的数字与x的差值的绝对值，分别为inc和dec，若dec > inc，说明delta减少了，更新具有最小delta窗的窗界。
5. 当滑动结束时，得到的具有最小delta的窗口内的数字即为所求的k个值。

此做法思路简单，代码如下。一开始有两个特判，分别处理x小于等于第一个数和x大于等于最后一个数的情形，第一种情形直接从第一个数开始取k个，第二种直接从最后一个数往前取k个。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n = arr.length, l = 0, r = n - 1;
        if(x <= arr[0]) return copy(arr, 0, k - 1); // 特判，从第一个数开始取k个
        else if(x >= arr[n - 1]) return copy(arr, n - k, n - 1); // 特判，从最后一个数往前取k个
        while(l <= r){
            int c = l + (r - l) / 2;
            if(arr[c] <= x) l = c + 1;
            else r = c - 1;
        }
        int idx = r; // 取得「小于等于」x 的下标
        l = Math.max(0, idx - k + 1); // 滑窗左界
        r = l; // 滑窗右界
        n = Math.min(n - 1, idx + k); // 滑动上界
        int minDelta = 0; // 窗内元素与x做差的绝对值之和
        for(; r < l + k; r++){ // 第一个窗口
            minDelta += Math.abs(arr[r] - x);
        }
        int minl = l, minr = r - 1; // 第一个窗的左右界
        while(r <= n){ // 滑动
            int inc = Math.abs(arr[r] - x);
            int dec = Math.abs(arr[l] - x);
            if(dec > inc){ // 更新使得minDelta更小的窗界
                minl++;
                minr++;
            }
            l++;
            r++;
        }
        return copy(arr, minl, minr);
    }

    private List<Integer> copy(int[] arr, int i, int j){
        List<Integer> res = new ArrayList<>();
        for(; i <= j; i++) res.add(arr[i]);
        return res;
    }
}
```

相比上述二分查找结合滑窗的做法，本题还有一种不太直接，但更为纯粹，效率也更高的二分查找做法。如下图，求数组中所有数字与x的差值的绝对值后，这些值形成两段单调区间，先下降后上升。存在两种特例，当x小于等于首个数字时只有一段单调非递减区间，当x大于等于最后一个数字时只有一段单调非递增区间，不过这不影响我们的分析。显然要求返回的k个数字是从最底部数字开始向上找位置最低的k个数字。如果我们能找到这个数字，那么从它开始的k个数字即为所求。首先，这k个数字中的首个的下标 l 一定落在[0, arr.length - k]区间。思考如何在[0, arr.length - k]区间上用二分查找寻找 l 时，应当首先寻找关于它的「循环不变」关系，即该数字左侧/右侧数字应满足的约束。回想题目要求并结合下图，绿点表示要所求的k (k = 8)个元素，点的高度表示对应的 |arr[i] - x| ，(1), (2)为同一数组的选择，表现稍后的「循环不变」关系1，其中(1)为错误选择，(2)为正确选择。(3), (4)为另一数组的选择，表现稍后的「循环不变」关系2，其中(3)为错误选择，(4)为正确选择。不难得出这个关系应为：1. arr[l] 左侧数字与x的差的绝对值，要大于arr[l + k - 1]与x的差的绝对值 (结合下图的(1), (2)观察); 2. arr[l]本身与x的差的绝对值，要小于等于arr[l + k - 1]与x的差的绝对值（结合下图的(3), (4)观察）。这具有强烈的「模版二」味道。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h270vdlpj5j213l0u0jtf.jpg" alt="image-20220513195420518" width="600;" />
</div>



根据上述分析，我们采用「模版二」写出如下代码，初始的 r 不必为 arr.length - k + 1，因为当 r 不更新时，说明 x 大于或等于最大值，最终得到的结果是正确的。反而如果 r = arr.length - k，那么之后的arr[c + k]可能越界。此外需要小心处理的地方仅有一处，即 if 中的条件。l 更新后，c 即为 l 的左侧，其左侧数字与x的差的绝对值即为 x - arr[c]，之所以不需要取绝对值是因为最终 l 必在最底部的左侧（或当x小于等于首个数字时 l 为最底部的下标）。又因为 c = l - 1，因此arr[l + k - 1] - x即此时的arr[c + k]，于是写出`if (x - arr[c] > arr[c + k] - x)`。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int l = 0, r = arr.length - k;
        List<Integer> res = new ArrayList<>();
        while(l < r){
            int c = l + (r - l) / 2;
            if(x - arr[c] > arr[c + k] - x) l = c + 1;
            else r = c;
        } // 循环结束后 l = r为所求k个元素的第一个的下标。
        for(int i = 0; i < k; i++){
            res.add(arr[i + r]);
        }
        return res;
    }
}
```

#### 29. 两数相除

[29. 两数相除](https://leetcode.cn/problems/divide-two-integers/) (中等)。这是一道应用了二分思想但解题过程并不能套用模版的题。在这里也详细展示求解过程。由于题目要求不能使用乘法、除法以及求余，因此考虑用加法代替乘法。对于 a / b, a、b都是整数，为了缩小讨论范围，假设a、b都是正数，那么商的范围为[0, a]，当a < b或b = 0(无意义)时为0。可以通过不断倍增b并将倍增结果与a比较来找到商，这实际上是一个二分搜索的过程。关键代码如下(a / b = c)。应当注意，b在倍增过程中，若超过最大值的一半，那么b + b会因为溢出得到负数，此时 <= a的判断将导致错误的结果，因此在while条件中要使得b <= Integer.MAX_VALUE / 2。例如a = Integer.MAX_VALUE, b = 1时，b会倍增到1073741824 > Integer.MAX_VALUE / 2 = 1073741823，不满足上述条件跳出循环（短路判断）。

```java
int c = 1; // 商
while(b <= Integer.MAX_VALUE >> 1 && b + b <= a){
  b += b; // 除数倍增
  c += c; // 商相应倍增
}
```

现在我们从一个例子出发，逐步完善求解过程。例如求解a = 100, b = 7。按照前述while，得到b, c的变化(b = 14, c = 2), (b = 28, c = 4), (b = 56, c = 8)，之后由于b + b = 112 > a，跳出循环。至此得到了a中56的部分被7除的结果，a剩余的部分100 - 56 = 44 > 7，因此仍然可继续被7除。由于在有剩余的情况下余下部分的大小需要与b进行比较，因此用d = b来表示除数的倍增变化，用ans来累计商。

```java
public int divide(int a, int b) {
    int ans = 0; // 最终的商
    while(a >= b) {
        int d = b, c = 1; // 当前倍增的部分商
        while(d <= Integer.MAX_VALUE >> 1 && d + d <= a) {
            d += d; // 除数倍增
            c += c; // 当前商倍增
        } 
        a -= d; // a剩余部分
        ans += c; // 累计商
    }
    return ans;
}
```

本题的求解框架如上，但这是基于a、b均为正整数的情况，当a、b不同号时，一个自然的想法是按正整数求解，返回结果时再取反即可。按照这个想法，现在来考虑a、b的符号以及edge cases。a、b的范围均为[-2^31, 2^31 - 1]，为方便，定义MIN = -2^31, MAX = 2^31 - 1。可以看到MIN的绝对值比MAX更大，当a = MIN时，对a取反会导致溢出。因此我们反其道而行之，按a、b都为负数处理，这样就可以覆盖所有a、b取值的情形。将前述假设a、b均为正数的代码修正为假设a、b均为负数的版本。另外对于第二个while中的(d + d <= a)，有经验的话不难察觉到d + d的写法可能导致加法溢出，因此改写为d <= a - d。但由于第一个条件已经避免了d + d溢出的情形，因此无需改写。



题目已经声明b != 0，因此无需考虑这个edge case。唯一需要处理的edge case是a = -2^31, b = -1，此时会溢出，按题目要求应该返回MAX。至此我们可以写出完整代码。



```java
public int divide(int a, int b) {
    int MIN = Integer.MIN_VALUE, MAX = Integer.MAX_VALUE, MIN_LIMIT = MIN >> 1; // -1073741824
    if(a == MIN && b == -1) return MAX; // 特判
    boolean isPos = (a < 0 && b > 0) || (a > 0 && b < 0) ? false : true;
    if(a > 0) a = -a;
    if(b > 0) b = -b;
    int ans = 0; // 最终的商
    while(a <= b) {
        int d = b, c = 1; // d为当前除数，c为当前商
        while(d >= MIN_LIMIT && d + d >= a) { // 通过第一个条件防止d + d溢出
            d += d; // 当前除数倍增，也可以用 d <<= 1;
            c += c; // 当前商倍增，也可以用d <<= 1;
        } 
        a -= d; // a剩余部分
        ans += c; // 累计当前商
    }
    return isPos ? ans : -ans;
}
```

有意思的是这种做法的时间复杂度为O((logc)^2)，而不是典型的对数复杂度。可以这么求解，从1开始倍增直到c的过程中，内层while内的语句执行次数由此式得到：log(c - x) + log(x - y) + log(y - z)...。x, y, z表示每次剩余的部分，且每次剩余的部分均小于当前部分的一半，最多共有logc项。可以看到虽然为对数平方阶，但随着项数增加，log中的真数快速下降，因此实际效率要好得多。也可以粗略地通过下式观察得出。

log(c - x) + log(x - y) + log(y - z)... < logc + log(c/2)+ log(c/4)... = logc * logc - log2 - log4...

#### 875. 爱吃香蕉的珂珂

[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) (中等)。二分变形题，需要通过数值映射来找到二分查找的对象。首先遍历一遍所有香蕉堆，找到最大的那堆，假设最多有max根香蕉。那么，k一定是{1,2,3,...,max}中的某个数。现在来做一个映射，对上面的序列中的每个数，求出k对应的耗费时间，即以速度k吃完所有香蕉，需要花费的时间，得到数组{h1,h2,h3,...hx}，于是问题转换为找到小于等于 h 的值的下标。采用「小于等于」情形的写法。需要注意的时，用于与 h 做比较的 hx，需要在每一次得到一个新 k 值后以一次遍历求出，hx > h 说明耗时较h多，需要加快速度，于是 l = k + 1。l 的左侧为耗时多于 h 的速度，因此最终返回 l。

```java
// 模版一
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int pile : piles) { // 确定最大香蕉堆的香蕉根数
            max = Math.max(max, pile); 
        }
        int l = 1, r = max; 
        while(l <= r){ 
            int hx = 0;
            int k = l + (r - l) / 2;
            for(int pile : piles) { // 求k对应的时间
                hx += (pile - 1) / k + 1; // 向上取整写法
            }
            if(hx > h) l = k + 1; // 耗时多于h，要加快速度
            else r = k - 1; // 耗时小于等于h，降低速度
        }
        return l; 
    }
}
```

模版二写法如下。

```java
// 模版二
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int pile : piles) { // 确定最大香蕉堆的香蕉根数
            max = Math.max(max, pile); 
        }
        int l = 1, r = max; 
        while(l < r){ 
            int hx = 0;
            int k = l + (r - l) / 2;
            for(int pile : piles) { // 求k对应的时间
                hx += (pile - 1) / k + 1; // 向上取整写法
            }
            if(hx > h) l = k + 1; // 耗时多于h，要加快速度
            else r = k; // 耗时小于等于h，降低速度
        }
        return l; 
    }
}
```

LCP 12. [小张刷题计划](https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/) （中等）
「力扣」第 1482 题：[制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)（中等）
「力扣」第 1011 题：[在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)（中等）
「力扣」第 1552 题：[两球之间的磁力](https://leetcode.cn/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/两球之间的磁力)（中等）
[774. 最小化去加油站的最大距离](https://leetcode.cn/problems/minimize-max-distance-to-gas-station/)

[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)