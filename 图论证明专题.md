| 类别   | 文章                                                         | 备注                                       |
| ------ | ------------------------------------------------------------ | ------------------------------------------ |
| 最短路 | [Dijkstra算法正确性证明](https://leetcode.cn/circle/discuss/jJQn7V/) | 数学归纳法 & 反证法                        |
|        | [Bellman-Ford及SPFA算法正确性证明(说明)](https://leetcode.cn/circle/discuss/xeEwYl/) | 兼谈BF与SPFA，SPFA与BFM的关系              |
|        | [Floyd算法正确性证明(说明)](https://leetcode.cn/circle/discuss/Nbzix4/) | 从动态规划角度说明                         |
| 最大流 | [最大流最小割定理证明](https://leetcode.cn/circle/discuss/tMIy36/) | 即FF方法正确性证明<br />FF: Ford-Fulkerson |
|        | [Edmonds-Karp算法复杂度证明](https://leetcode.cn/circle/discuss/tN3sZc/) | $O(|V||E|^2)$                              |
|        | [Dinic算法复杂度证明](https://leetcode.cn/circle/discuss/T9Xa1R/) | $O(|V|^2|E|)$                              |



## Dijkstra算法正确性证明

### 算法描述

[Dijkstra算法(狄杰斯特拉算法)](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)：
一种基于广度优先搜索和贪婪思想的求解 **无负边有向赋权图单源最短路径** 的算法。
算法将所有顶点区分为「到源点 $s$ 的最短距离」(以后简称「距离」) **已确定** 和 **未确定** 的顶点。算法开始前所有顶点的距离均未确定(一般置为$Infinity$)，初始时置 $s$ 的距离为 0。以一个while循环查询当前 **是否有距离未确定** 的顶点，若有则将其中距离最小者 $v$ 选为 **当前顶点**，并**使其距离已知**。然后以BFS的方式松弛 $v$ 的邻接顶点 $w$ 并更新 $w$ 的前驱为 $v$。当不再有未确定距离的顶点时算法结束，此时每一个顶点的距离均最小。通过递归寻找节点的前驱可以得到 $s$ 到该顶点的具体的最短路径。

**松弛操作** 是最短路径算法的关键，在确定当前顶点 $v$ (最新成为已确定距离的顶点) 后立即操作，目的是更新 $v$ 的邻接顶点 $w$ 的距离和其前驱。如下图，$s$ 经过若干个顶点到 $a$ 和 $b$，$a$ 和 $b$ 邻接 $c$。假设此时 $dw = Inifinity$，$da = 5$，$db = 10$。

$a$ 先于 $b$ 成为当前顶点，由于 $da + |(a, w)| = 15 < Infinity$，故 $a$ 松弛 $dw$，并将 $w$ 的前驱置为 $a$，$w.pre = a$。

$b$ 成为当前顶点时，由于 $db + |(b, w)| = 11 < 15$，故 $b$ 松弛 $dw$，并将 $w$ 的前驱置为 $b$，$w.pre = b$。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyd7dgs29zj307m0di0sw.jpg" alt="image" width="100"/>
</div>

一个直观的观察是，来自 $w$ 入边的松弛，使得 $dw$ 不断更新至所有可能的路径距离的最小值。以下严格证明该算法正确性。

<br />

### 算法正确性证明

利用数学归纳法(结合反证法)证明。

> 本证明参考了[这个帖子](https://www.zhihu.com/question/57206374)。

#### a) 数学归纳法的证明过程

1.  起始验证。对于命题 $P(n)$，当 $n = 1$ 时命题 $P$ 成立。

2.  假设命题成立。假设命题 $P(n)$ 在 $n = m (m > 1, m ∈ N)$ 时成立。

3.  递推证明。根据2的假设，若能证明 $n = m + 1$ 时命题 $P$ 成立，则命题得证。

例如，有命题 $P：1+2+3...+n = n*(n+1)/2$，按照数学归纳法证明如下：

1.  起始验证。当 $n$ 等于 $1$ 时，$1 = 1*(1+1)/2$，命题成立。

2.  假设命题成立。假设命题等于 $m$ 时成立，$1+2+3+...+m = m*(m+1)/2$。

3.  递推证明。根据2的假设，如果能证明 $n = m+1$ 时命题正确，则命题 $P$ 成立。

    证明：在2所示式子左右两边加上 $m+1$，得到 $1+2+3+...+m+(m+1) = m*(m+1)/2 + (m+1)$

    等号右边可以写成 $(m+1)*(m+2)/2$，显然该形式就是将 $n = m+1$代入原命题 $P$ 的形式，证毕。

<br />

#### b) 证明Dijkstra算法的正确性

命题 $P$：Dijkstra算法第 $n$ 次进入while时，会将第 $n$ 个顶点加入距离已确定顶点集合 $A$ 中，此时对于顶点 $∀v ∈ A($共 $n$ 个)，总有 $dv = δv$。

※ $dv$ 表示由Dijkstra算法得到的最短距离估计，对于源点 $s$ ，在程序开始时赋予 $ds = 0$，对于其他顶点，由松弛操作得到。$δv$ 表示实际的顶点 $v$ 到源点的最短距离。

1.  起始验证。当 $n$ 等于 $1$ 时，$A$ 集合中只有源点 $s$ 自身，$ds = 0$ (程序开始时赋值得到)，且知 $δv = 0$，故 $n=1$ 时命题正确。

2.  假设命题成立。假设命题 $P$ 在 $n$ 等于 $m$ 时，$P(m)$ 成立，即算法经过 $m$ 次while，得到具有 $m$ 个顶点的集合 $A$，对于顶点 $∀v ∈ A$ (共 $m$ 个)，总有 $dv = δv$。

3.  $P(m+1)$ 递推证明。根据 2 的假设，如果能证明第 $m+1$ 个顶点 $u$ 被放入集合 $A$ 时有 $du = δu$，则命题 $P$ 成立。

    更详细地，$|A| = m$ 时，在点集 $B (B = S - A)$ 中根据算法规则找到距离最短的顶点 $u$，将该顶点将作为第 $m+1$ 个顶点放入A中，放入后 $|A| = m + 1$，如果能证明 $du = δu$，使得 $P(m+1)$ 成立，则对于顶点 $∀v ∈ A$ (共 $m+1$ 个)，有 $dv = δv$。

    以反证法证明之。
    <br />
    3.1 假设 $m+1$ 时 $du = δu$ 不成立，即有如下式(1)， 之后的目标是 **根据已知条件导出某种矛盾情形**，推翻该假设。

    (1)    $δu < du$

    ※ $δu$ 是实际的 $u$ 到源点的最短距离，$du = δu$ 不成立时只能是 $δu < du$。算法保证了从 $s$ 到 $u$ 的过程一定是一条由图中的有向边构成的 **连续路径**，只要是连续路径，无论有多少条这样的路径，一定有一条最短路径，其长度记作 $δu$。并使得其他路径长度必大于等于 $δu。$
    <br />
    3.2 根据3.1的假设，存在一条从源点 $s$ 到 $u$ 的路径 $Pu$，该路径是 $s$ 到 $u$ 的最短路径，即 $|Pu| = δu  < du$。路径 $Pu$ 一定有不在 $A$ 集内的顶点 (至少有 $u$ 不在 $A$ 集中，注意此时 $u$ 还未被选入 $A$ 中)，同时也有在 $A$ 集中的点 (至少有 $s$ 点在 $A$ 集中)，可以假设 $Pu$ 经过 $x$ 和 $y$，其中 $x$ 在A中 (可以是 $s$)，$y$ 在B中 (可以是 $u$ 本身)，$y$ 到 $u$ 的过程中也可以再进入 $A$，如下图。$Px$ 为 $Pu$ 在顶点 $x$ 结束的子路径，因为路径 $Px + (x, y)$ 为路径 $Pu$ 的一部分，所以有：

    (2)    $|Px| + |(x, y)| ≤ |Pu| = δu$

    这是显然的，因为 $Px + (x, y)$ 是 $Pu$ 的一部分，当 $y=u$ 时取到等号。

    <div align=center> 
      <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvlx6lkq0wj60nw0f6mxj02.jpg" width="250" />
    </div>
    
    <br />
    
    3.3 在 $x$ 之前被选中进入 $A$ 集内时，对其邻接顶点 $y$ 执行过 **松弛操作**，该操作会比较 $dx + |(x, y)|$ 是否小于 $dy$，若小于则以 $dx + |(x, y)|$ 更新 $dy$ 的值，所以如果更新了，更新之后有 $dy = dx + |(x, y)|$ ，如果没更新，说明 $dy < dx + |(x, y)|$。假设之后 $y$ 还会被 $y$ 的其他前驱顶点更新 $dy$ 值 (当该前驱顶点进入 $A$ 集时)，那 $dy$ **只会变得更小**，所以一定有：
    
    (3)    $dy ≤ dx + |(x, y)|$
    
    比较式 (2) 和式 (3) 中的 $|Px|$ 和 $dx$，因为 $dx = δx$  (由步骤2的 $P(m)$ 假设给出，顶点 $x$ 是 $P(m)$ 假设的 $m$ 个顶点之一)，而 $Px$ 只是若干从 $s$ 到 $x$ 的路径之一，因此必有 $d(x) ≤ |Px|$，当 $Px$ 恰是 $s$ 到 $x$ 的最短路径时取到等号。所以根据式 (2) 和式 (3) 有：
    
    $dy ≤ dx + |(x, y)| ≤ |Px| + |(x, y)| ≤ |Pu|$，即

    (4)    $dy ≤ |Pu| = δu$
    <br />
    
    3.4 顶点 $y$ 与 $u$ 均在 $B$ 集中，根据算法规则，$u$ 作为第 $m+1$ 个定点被放入 $A$ 集中时，其在 $B$ 集中相比于$B$ 集中的其他顶点(自然也包括 $y$ )，到源点 $s$ 的距离最小，显然有：
    
    (5)    $du ≤ dy$
    
    结合式 (1)，式 (4)，式 (5)得到：
    
    (6)    $δu < du ≤ dy ≤ |Pu| = δu$ ，即  $δu < δu$

至此，由3.1的假设 「$d(u) = δ(u)$ 不成立」导出了 **矛盾**，所以 $d(u) = δ(u)$ 是成立的，Dijkstra算法正确性得证。

<br />

## Edmonds-Karp算法复杂度证明

**[EK算法](https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm)：** 以BFS方式 (无权最短路径) 寻找增广路径实现 Ford-Fulkerson 方法即为 Edmonds-Karp 算法。每找到一条增广路并确定该路径上的最小边权(该路径最大可发送流)后，将此边权计入最大流中，并在此路径上对 $s > t$ 方向的边减去该权值，$t > s$ 方向上加上该权值。当BFS无法再找到增广路时算法结束，得到 $s$ 到 $t$ 的最大流。

<br />

### 证明时间复杂度为：$O(|V||E|^2)$

> 本证明参考了[证明1](http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=f6cdf7ef750d7dc79c7d599b942acbaaee86a2e3e)、[证明2](https://brilliant.org/wiki/edmonds-karp-algorithm/)。

#### 1. 一次BFS增广: $O(|E|)$

每次BFS增广，在增广路上的未饱和边会多出一条反向边，故增广操作导致的边数增长不会使总边数超过原来的 2 倍，即算法的任意时刻总边数 $< 2|E|$。一次BFS的时间复杂为 $O(2|E|)$，即 $O(|E|)$。详细可参考利用队列的无权最短路径复杂度分析。

#### 2. BFS增广次数: $O(|V||E|)$

##### 2.1 增广路长度非递减

即证明算法过程中的 $s$ 到 $t$ 的BFS增广操作，即正向边删除和反向边增加的操作，不会导致源点 $s$ 到任意一点 $v$ 的最短路径距离减少。残留图 $G_f$ 经过一次BFS增广变为 $G_{f'}$ 后，对任意顶点 $v$ ，源点 $s$ 到 $v$ 的最短路径长度 **非递减**，即有 $d'(s, v) ≥ d(s, v)$。以下利用反证法证明，并在证明中解释为何**只能证明非递减而无法证明严格递增**，即 $d'(s, v) > d(s, v)$。

1. 假设某一次 $s - t$ 增广后，使得某些顶点到源点 $s$ 的最短路径距离相比增广前变小了，且这其中距离源点 $s$ 最近者为 $v$。则根据该假设有

   (1)    $d'(s, v) < d(s, v)$ 

2. 令 $u$ 为 $G_{f'}$ 中 $v$ 的靠近源点 $s$ 的前一个顶点，则有

   (2)    $d'(s, u) + 1= d'(s, v)$ 

   

   如 2.1.1 所述，$v$ 是我们有意选择的在 $G_{f'}$ 中最短距离相比在 $G_f$ 中变小的且距离 $s$ 最近的顶点，$u$ 比 $v$ 更靠近 $s$，但在 $G_{f'}$ 中相比在 $G_f$ 中距离 $s$ 的最短路径未变小，即有

   (3)    $d(s, u) ≤ d'(s, u)$ 

3. 假设 $(u, v) ∈ E_f$，已知 $s$ 到 $v$ 的最短路径距离为 $d(s, v)$，则有

   (4)    $d(s, u) + 1 = d(s, v)$

   

   结合(1)、(2)、(3)有 

   $d(s, u) ≤ d'(s, u) → d(s, u) + 1 ≤ d'(s, u)+ 1 = d'(s, v)  < d(s, v)$，即

   (5)    $d(s, u) + 1 <  d(s, v)$ 

   

   (4) 是由 2.1.3 的假设得到的，与由 (1), (2), (3) 得到的 (5) 矛盾，故在 2.1.1 假设成立的前提下，2.1.3 的假设 $(u, v) ∈ E_f$ 不成立，即 $(u, v) ∉ E_f$。同时我们还能看到，如果一开始证明的是 $d'(s, v) > d(s, v)$，那么就要反证 $d'(s, v) ≤ d(s, v)$ (即式(1))，经过同样的过程当前的式 (5) 会变为 $d(s, u) + 1 ≤  d(s, v)$，将推导不出与 (4) 式的矛盾（因为都有一个等号）。

4. 由上述知 $(u, v) ∉ E_f$，但如 2.1.2 所述，$(u, v) ∈ E_{f’}$ ，故在 $G_f$ 上的增广必定经过了 $(v, u)$，且此边饱和，导致在 $G_{f'}$ 中产生了反向边 $(u, v)$。于是可知在 $G_f$ 中有

   (6)    $d(s, u) = d(s, v) + 1$

   

(6) 与 (5) 矛盾，于是最初 2.1.1 的假设不成立，即不存在这样的顶点 $v$，也即增广操作使得源点到任意一点 $v$ 的长度 **非递减**， **故EK算法寻找的增广路长度非递减**。

每次增广，在增广路上的未饱和边会多出一条反向边，故增广操作导致的边数增长不会使总边数超过原来的 2 倍，即 $|E'| < 2|E|$。又知道增广路长度是非递减的，增广路上界是总边数 ( $< 2|E|$ )，故任意一次BFS寻找增广路的时间复杂度总是 $O(|E|)$。

##### 2.2 增广次数: $O(|V||E|)$

1. 假设某次 $G_f$ 的增广中 $(u, v)$ 为饱和边，增广后 $(u, v) ∉ E_{f'}$，$(v, u) ∈ E_{f'}$。之后 $(u, v)$ 要再次出现的前提是 $(v, u)$ 为饱和边。在 $G_f$ 中  $(u, v)$ 第一次成为饱和边时有

   (7)    $d(s, v) = d(s, u) + 1$

2. 若 $(u, v)$ 第二次成为饱和边，可知在此前的 $G_{f'}$ 中 $(v, u)$ 中为饱和边，在 $G_{f'}$ 的这次增广中有

   (8)    $d'(s, u) = d'(s, v) + 1$

3. 由 2.1 的结论，$s$ 到任意顶点的最短路径非递减，即必有 $d'(s, v)  ≥ d(s, v)$ ，结合 (7) 和 (8)，有

   $d'(s, u) = d'(s, v) + 1 ≥ d(s, v) + 1 = d(s, u)+ 2$，即

   (9)    $d'(s, u)   ≥ d(s, u) + 2$

也就是说，$(u, v)$ 第二次成为饱和边时 $s$ 到 $u$ 的最短距离至少比前一次成为饱和边时大 2。而 $s$ 到任意顶点的距离最多不超过$|V| - 1$，故 $(u, v)$ 可以成为饱和边的次数最多为 $(|V| - 1) / 2$。每次增广至少有一条边成为饱和边，根据 2.1 中的说明，EK算法过程中边数 $< 2|E|$，故考虑 **所有边的总的增广次数必小于** $2|E|*(|V| - 1)/2$，即 **增广次数复杂度为 $O(|V||E|)$**。

**综上，EK算法复杂度为 $O(|V||E|^2)$。**

<br />

证明过程中**BFS增广使得增广路长度非递减**的结论是关键，网上有的文章声称BFS寻找增广路的操作使得增广路长度递增，但我们已经在 2.1.3 的叙述中指出这是不对的。根据 2.1 的证明，只能得到 **非递减** 的结果，但这一结论在 2.2 中足以证明任意边第二次成为饱和边时其最短路径长至少增加2，由此得到BFS次数的上界。

<br />



## Dinic算法复杂度证明

**[Dinic算法](https://en.wikipedia.org/wiki/Dinic%27s_algorithm)：** 相比EK算法以BFS方式实现FF方法中的增广操作，在Dinic算法中，采用BFS和DFS结合的方式增广。首先引入 **高度标号(层次标号)** 和 **分层图** 的概念。以BFS算法从 $s$ 到 $t$ ，标记 $s$ 为第1层，$s$ 的邻接顶点为第2层，以此类推 $t$ 为最后一层。执行一次BFS，赋予每个顶点高度标号信息，此时的图称作 **分层图(层次图)**。在此分层图内以DFS方式反复寻找增广路并执行增广操作(找到饱和边，发送和发回流)，累计发送流。完成当前分层图的所有增广操作称作 **一个阶段**。一个阶段结束后，**重置高度标号信息**，再次执行BFS得到新的分层图并重复DFS的增广操作，**直到无法分层** 时说明 $s$ 到 $t$ 已无增广路，算法结束，此时得到的发送流总和即为 $s$ 到 $t$ 的 **最大流**。

高度标号的作用：在以DFS增广时，每次从顶点 $v$ 到其邻接顶点 $w$ 的路径增长，都要考察 $w$ 的的高度是否比 $v$ 的高度大1，以此来保证路径总是能按步增长到最后一层的 $t$ (在有增广路的前提下)。



### 证明时间复杂度为：$O(|V|^2|E|)$

>  如下证明参考了[COMPSCI 638: Graph Algorithms, Lecture3](https://courses.cs.duke.edu/fall19/compsci638/fall19_notes/lecture3.pdf)。

#### 1. BFS建立分层图: $O(|E|)$

可参考无权最短路径复杂度分析，略。

#### 2. 一次DFS增广: $O(|V|)$

在分层图中，由于高度标号加一的判断条件限制，DFS只能沿着高度递增的方向从 $s$ 到 $t$ 推进，因此单次DFS推进次数最多不超过 $|V|-1$ 次，时间复杂度为 $O(|V|)$。

#### 3. 一个阶段中DFS增广次数：$O(|E|)$

在分层图中，每次DFS增广的结果使得一条高度递增方向上的饱和边 $(u, v)$ 消失，此边的反向边 $(v, u)$ 增加。如前述，**增广路只能沿着高度递增的方向**，而同一阶段内(同一张分层图中)反向边是沿着高度递减方向增加的。$(u, v)$ 消失后再次出现的条件是 $(v, u)$ 为此后某次增广路上的饱和边。**再次强调**，在 **同一阶段内** (同一张分层图中)，$(v, u)$方向是**高度递减**的，不可能出现在增广路上，因此一条高度递增边 $(u, v)$ 被删除后不会再次出现。一次增广至少令一条高度递增边饱和并删除，高度递增边数量不大于$|E|$，于是 **一个阶段内DFS的次数最多为 $|E|$，即 $O(|E|)$**。结合 2 可知，**一个阶段的总复杂度为单次DFS的复杂度与DFS次数的乘积，即 $O(|V||E|)$**。

#### 4. 阶段数(分层图建立次数): $O(|V|)$

**此证明是难点。** 如前述，在层高递增条件的限制下，$s - t$ 最短路径长度即 $t$ 的层高，因此最短路径最大不超过 $|V| - 1$。如果能证明每次分层图使得 $s - t$ 最短路径长 **「严格」递增** ，则立即推出阶段数(分层图建立次数)的上限为 $|V|$，复杂度为 $O(|V|)$。最短路径长严格递增的证明如下。

令相邻的两次分层图为 $G_f$  和 $G_{f'}$ ，以 $d(u, v)$ 和 $d'(u, v)$ 分别表示$G_f$  和 $G_{f'}$ 中的 $u$ 到 $v$ 的最短距离。

1. 由[Edmonds-Karp算法复杂度证明](https://leetcode-cn.com/circle/discuss/tN3sZc/)已知 (这一点很重要)，删正向边加反向边的操作，使得**源点 $s$ 到任意一点 $u$ 的距离是非递减**的，即 **必有** $d'(s, u) ≥ d(s, u)$。对证明过程稍加改造很容易得到一个对汇点 $t$ 来说类似的结论，即删正向边加反向边的操作，使得任意一点 $u$ 到汇点 $t$ 的距离是非递减的，即 **必有** $d'(u, t) ≥ d(u, t)$。

   (1)    $d'(s, u) ≥ d(s, u)$

   (2)    $d'(u, t) ≥ d(u, t)$ 

对于 $s - t$ 来说有 $d'(s, t) ≥ d(s, t)$。接下来的证明目标是**拿掉该不等式中的等号**，证明 $G_{f'}$ 相比 $G_f$，严格地有 $d'(s, t) > d(s, t)$。可用**反证法证明不可能取等号**。

2. **假设 $d'(s, t) ≥ d(s, t)$ 可以取到等号**。 
   若$G_{f'}$ 有一条 $s$ 到 $t$ 的最短路径 $f'$，则一定存在边 $(x, y) ∈ E_{f'}$，是 $G_f$ 某条增广路饱和边的反向边。因为如果 $E_{f'}$ 都是 $G_f$ 中存在的边，由于 $d'(s, t) = d(s, t)$，这样的 $f'$ 路径在 $G_f$ 中就**一定**已经被找到了。因此在 $G_f$ 中有 $(y, x) ∈ E_f$ ，于是有

   (3)    $d(s, x) = d(s, y) + 1$

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h29ezrs42cj20aq0fa74i.jpg" alt="image-20220515213405940" width="180;" />
</div>


3. 由 (1) 和 (2) 易知

   (4)    $d'(s, x) ≥ d(s, x)$  

   (5)    $d'(y, t) ≥ d(y, t)$

4. $f'$ 路径长可写成 $d'(s, t) = d'(s, x) + 1 + d'(y, t)$ ，应用 (4) 和 (5) 得到

   $d'(s, t) = d'(s, x) + 1 + d'(y, t) ≥ d(s, x) + 1 + d(y, t)$ 

   又由 (3) 得到

   $d'(s, t) = d'(s, x) + 1 + d'(y, t) ≥ d(s, x) + 1 + d(y, t) = d(s, y) + d(y, t) + 2$

   即

   (6)    $d'(s, t) ≥ d(s, t) + 2$

由此，$d'(s, t) = d(s, t)$ 的假设不成立，但我们知道 $d'(s, t) ≥ d(s, t)$ ，因此有 $d'(s, t) > d(s, t)$ ，也即证明了**Dinic算法中下一分层图的最短路径长度与前一分层图相比严格递增**。

<br />

综上，总时间复杂度为每个阶段建立分层图的复杂度 $O(|E|)$ 与在该分层图内执行的总DFS复杂度 $O(|V||E|)$ 之和乘以阶段数 $O(|V|)$，为 $O((|E|+|V||E|)*|V|)$，即 $O(|V|^2|E|)$。